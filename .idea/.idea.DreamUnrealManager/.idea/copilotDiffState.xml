<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/DreamUnrealManager/Views/PluginsBuildPage.xaml.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DreamUnrealManager/Views/PluginsBuildPage.xaml.cs" />
              <option name="originalContent" value="using Microsoft.UI.Xaml;&#10;using Microsoft.UI.Xaml.Controls;&#10;using Microsoft.UI.Xaml.Documents;&#10;using Microsoft.UI.Xaml.Media;&#10;using System;&#10;using System.IO;&#10;using System.Threading.Tasks;&#10;using Windows.Storage;&#10;using Windows.Storage.Pickers;&#10;using System.Diagnostics;&#10;using System.Threading;&#10;using System.Text;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using System.Text.Json;&#10;using DreamUnrealManager.Services;&#10;using DreamUnrealManager.Models;&#10;using Windows.UI;&#10;using Microsoft.UI;&#10;&#10;namespace DreamUnrealManager.Views&#10;{&#10;    public sealed partial class PluginsBuildPage : Page&#10;    {&#10;        private CancellationTokenSource _buildCancellationTokenSource;&#10;        private bool _isBuildInProgress = false;&#10;        private Process _currentProcess;&#10;        private readonly EngineManagerService _engineManager;&#10;        private PluginInfo _currentPluginInfo;&#10;        private List&lt;CheckBox&gt; _engineCheckBoxes = new List&lt;CheckBox&gt;();&#10;&#10;        // 批量构建相关字段&#10;        private List&lt;UnrealEngineInfo&gt; _selectedEnginesForBatch;&#10;        private int _currentBatchIndex;&#10;        private List&lt;string&gt; _batchBuildResults;&#10;&#10;        // 错误和警告跟踪&#10;        private List&lt;BuildIssue&gt; _buildIssues = new List&lt;BuildIssue&gt;();&#10;        private int _errorCount = 0;&#10;        private int _warningCount = 0;&#10;        private UnrealEngineInfo _currentBuildingEngine;&#10;&#10;        public PluginsBuildPage()&#10;        {&#10;            this.InitializeComponent();&#10;            _engineManager = EngineManagerService.Instance;&#10;            this.Loaded += PluginsBuildPage_Loaded;&#10;        }&#10;&#10;        #region 构建问题类定义&#10;&#10;        public enum BuildIssueType&#10;        {&#10;            Error,&#10;            Warning&#10;        }&#10;&#10;        public class BuildIssue&#10;        {&#10;            public BuildIssueType Type&#10;            {&#10;                get;&#10;                set;&#10;            }&#10;&#10;            public string Message&#10;            {&#10;                get;&#10;                set;&#10;            }&#10;&#10;            public string Engine&#10;            {&#10;                get;&#10;                set;&#10;            }&#10;&#10;            public DateTime Timestamp&#10;            {&#10;                get;&#10;                set;&#10;            }&#10;&#10;            public string SourceFile&#10;            {&#10;                get;&#10;                set;&#10;            }&#10;&#10;            public int LineNumber&#10;            {&#10;                get;&#10;                set;&#10;            }&#10;        }&#10;&#10;        #endregion&#10;&#10;        private async void PluginsBuildPage_Loaded(object sender, RoutedEventArgs e)&#10;        {&#10;            try&#10;            {&#10;                await InitializePage();&#10;&#10;                // 初始化导航状态为就绪&#10;                UpdateNavigationStatus(false, 0, &quot;就绪&quot;);&#10;&#10;                // 页面加载完成后显示欢迎消息&#10;                WriteToTerminal(&quot;插件构建页面已就绪&quot;, TerminalMessageType.Success);&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                System.Diagnostics.Debug.WriteLine($&quot;页面加载失败: {ex.Message}&quot;);&#10;                UpdateNavigationStatus(false, 0, &quot;初始化失败&quot;);&#10;            }&#10;        }&#10;&#10;&#10;        private async Task InitializePage()&#10;        {&#10;            try&#10;            {&#10;                var documentsPath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);&#10;                OutputPathTextBox.Text = Path.Combine(documentsPath, &quot;PluginsBuilded&quot;);&#10;&#10;                await LoadEngineVersions();&#10;&#10;                // 确保页面完全加载后再显示初始化消息&#10;                if (this.IsLoaded)&#10;                {&#10;                    WriteToTerminal(&quot;页面初始化完成&quot;, TerminalMessageType.Success);&#10;                }&#10;&#10;                UpdateIssuesCounts();&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                System.Diagnostics.Debug.WriteLine($&quot;初始化错误: {ex.Message}&quot;);&#10;                // 初始化时的错误不显示在终端中&#10;            }&#10;        }&#10;&#10;&#10;        private async Task LoadEngineVersions()&#10;        {&#10;            try&#10;            {&#10;                await _engineManager.LoadEngines();&#10;&#10;                EngineVersionComboBox.Items.Clear();&#10;                var validEngines = _engineManager.GetValidEngines();&#10;&#10;                if (validEngines != null)&#10;                {&#10;                    foreach (var engine in validEngines)&#10;                    {&#10;                        var displayText = $&quot;{engine.DisplayName}&quot;;&#10;                        if (!string.IsNullOrEmpty(engine.FullVersion))&#10;                            displayText += $&quot; ({engine.FullVersion})&quot;;&#10;                        else if (!string.IsNullOrEmpty(engine.Version))&#10;                            displayText += $&quot; ({engine.Version})&quot;;&#10;&#10;                        var item = new ComboBoxItem&#10;                        {&#10;                            Content = displayText,&#10;                            Tag = engine&#10;                        };&#10;                        EngineVersionComboBox.Items.Add(item);&#10;                    }&#10;                }&#10;&#10;                if (EngineVersionComboBox.Items.Count &gt; 0)&#10;                    EngineVersionComboBox.SelectedIndex = 0;&#10;&#10;                LoadBatchEnginesList();&#10;&#10;                // 只有在页面完全加载后才显示加载消息&#10;                if (this.IsLoaded)&#10;                {&#10;                    WriteToTerminal($&quot;已加载 {validEngines?.Count() ?? 0} 个有效引擎版本&quot;, TerminalMessageType.Info);&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                System.Diagnostics.Debug.WriteLine($&quot;加载引擎版本失败: {ex.Message}&quot;);&#10;                // 初始化时的错误不显示在终端中&#10;            }&#10;        }&#10;&#10;&#10;        private void LoadBatchEnginesList()&#10;        {&#10;            try&#10;            {&#10;                EngineVersionsCheckList.Children.Clear();&#10;                _engineCheckBoxes.Clear();&#10;&#10;                var validEngines = _engineManager.GetValidEngines();&#10;                if (validEngines != null)&#10;                {&#10;                    foreach (var engine in validEngines)&#10;                    {&#10;                        var displayText = $&quot;{engine.DisplayName}&quot;;&#10;                        if (!string.IsNullOrEmpty(engine.FullVersion))&#10;                            displayText += $&quot; ({engine.FullVersion})&quot;;&#10;                        else if (!string.IsNullOrEmpty(engine.Version))&#10;                            displayText += $&quot; ({engine.Version})&quot;;&#10;&#10;                        var checkBox = new CheckBox&#10;                        {&#10;                            Content = displayText,&#10;                            Tag = engine,&#10;                            Margin = new Thickness(0, 2, 0, 2)&#10;                        };&#10;&#10;                        _engineCheckBoxes.Add(checkBox);&#10;                        EngineVersionsCheckList.Children.Add(checkBox);&#10;                    }&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                System.Diagnostics.Debug.WriteLine($&quot;加载批量构建列表失败: {ex.Message}&quot;);&#10;                // 初始化时的错误不显示在终端中&#10;            }&#10;        }&#10;&#10;&#10;        #region 终端输出方法&#10;&#10;        private enum TerminalMessageType&#10;        {&#10;            Info,&#10;            Success,&#10;            Warning,&#10;            Error,&#10;            Command&#10;        }&#10;&#10;        private void WriteToTerminal(string message, TerminalMessageType messageType = TerminalMessageType.Info)&#10;        {&#10;            DispatcherQueue.TryEnqueue(() =&gt;&#10;            {&#10;                try&#10;                {&#10;                    // 如果页面还没加载完成，直接返回&#10;                    if (!this.IsLoaded || TerminalOutput == null)&#10;                    {&#10;                        return;&#10;                    }&#10;&#10;                    // 过滤掉一些噪音信息&#10;                    if (ShouldFilterMessage(message))&#10;                    {&#10;                        return;&#10;                    }&#10;&#10;                    var timestamp = DateTime.Now.ToString(&quot;HH:mm:ss&quot;);&#10;                    var paragraph = new Paragraph();&#10;&#10;                    // 添加时间戳&#10;                    var timeRun = new Run { Text = $&quot;[{timestamp}] &quot; };&#10;                    timeRun.Foreground = new SolidColorBrush(Colors.Gray);&#10;                    paragraph.Inlines.Add(timeRun);&#10;&#10;                    // 根据消息类型设置颜色&#10;                    var messageRun = new Run { Text = message };&#10;                    switch (messageType)&#10;                    {&#10;                        case TerminalMessageType.Success:&#10;                            messageRun.Foreground = new SolidColorBrush(Colors.LightGreen);&#10;                            break;&#10;                        case TerminalMessageType.Warning:&#10;                            messageRun.Foreground = new SolidColorBrush(Colors.Yellow);&#10;                            break;&#10;                        case TerminalMessageType.Error:&#10;                            messageRun.Foreground = new SolidColorBrush(Colors.LightCoral);&#10;                            break;&#10;                        case TerminalMessageType.Command:&#10;                            messageRun.Foreground = new SolidColorBrush(Colors.Cyan);&#10;                            break;&#10;                        default:&#10;                            messageRun.Foreground = new SolidColorBrush(Colors.LightGray);&#10;                            break;&#10;                    }&#10;&#10;                    paragraph.Inlines.Add(messageRun);&#10;&#10;                    TerminalOutput.Blocks.Add(paragraph);&#10;&#10;                    // 检查是否包含错误或警告&#10;                    CheckForIssues(message, messageType);&#10;&#10;                    // 自动滚动到底部，确保 ScrollViewer 存在&#10;                    if (TerminalScrollViewer != null)&#10;                    {&#10;                        TerminalScrollViewer.ScrollToVerticalOffset(TerminalScrollViewer.ExtentHeight);&#10;                    }&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    System.Diagnostics.Debug.WriteLine($&quot;WriteToTerminal error: {ex.Message}&quot;);&#10;                }&#10;            });&#10;        }&#10;&#10;&#10;        // 改进 CheckForIssues 方法，添加更智能的错误检测&#10;        private void CheckForIssues(string message, TerminalMessageType messageType)&#10;        {&#10;            try&#10;            {&#10;                var lowerMessage = message.ToLower();&#10;&#10;                // 首先检查是否是已知的误报&#10;                if (IsFalseError(message))&#10;                {&#10;                    return;&#10;                }&#10;&#10;                var isError = IsRealError(message, messageType);&#10;                var isWarning = IsRealWarning(message, messageType);&#10;&#10;                if (isError || isWarning)&#10;                {&#10;                    var issue = new BuildIssue&#10;                    {&#10;                        Type = isError ? BuildIssueType.Error : BuildIssueType.Warning,&#10;                        Message = message,&#10;                        Engine = _currentBuildingEngine?.DisplayName ?? &quot;未知引擎&quot;,&#10;                        Timestamp = DateTime.Now,&#10;                        SourceFile = ExtractSourceFile(message),&#10;                        LineNumber = ExtractLineNumber(message)&#10;                    };&#10;&#10;                    _buildIssues.Add(issue);&#10;&#10;                    if (isError)&#10;                        _errorCount++;&#10;                    else&#10;                        _warningCount++;&#10;&#10;                    AddIssueToList(issue);&#10;                    UpdateIssuesCounts();&#10;                    ShowIssuesCard();&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                System.Diagnostics.Debug.WriteLine($&quot;CheckForIssues error: {ex.Message}&quot;);&#10;            }&#10;        }&#10;&#10;&#10;        private string ExtractSourceFile(string message)&#10;        {&#10;            try&#10;            {&#10;                // 尝试提取类似 &quot;C:\path\file.cpp(123)&quot; 的文件路径&#10;                var match = System.Text.RegularExpressions.Regex.Match(message, @&quot;([A-Za-z]:[^:]*\.(cpp|h|cs|hpp|c))\((\d+)\)&quot;);&#10;                if (match.Success)&#10;                {&#10;                    return System.IO.Path.GetFileName(match.Groups[1].Value);&#10;                }&#10;&#10;                // 尝试提取其他格式的文件路径&#10;                match = System.Text.RegularExpressions.Regex.Match(message, @&quot;([A-Za-z]:[^:]*\.(cpp|h|cs|hpp|c))&quot;);&#10;                if (match.Success)&#10;                {&#10;                    return System.IO.Path.GetFileName(match.Groups[1].Value);&#10;                }&#10;&#10;                return &quot;&quot;;&#10;            }&#10;            catch&#10;            {&#10;                return &quot;&quot;;&#10;            }&#10;        }&#10;&#10;        private int ExtractLineNumber(string message)&#10;        {&#10;            try&#10;            {&#10;                var match = System.Text.RegularExpressions.Regex.Match(message, @&quot;\((\d+)\)&quot;);&#10;                if (match.Success &amp;&amp; int.TryParse(match.Groups[1].Value, out int lineNumber))&#10;                {&#10;                    return lineNumber;&#10;                }&#10;&#10;                return 0;&#10;            }&#10;            catch&#10;            {&#10;                return 0;&#10;            }&#10;        }&#10;&#10;        private void AddIssueToList(BuildIssue issue)&#10;        {&#10;            DispatcherQueue.TryEnqueue(() =&gt;&#10;            {&#10;                try&#10;                {&#10;                    var border = new Border&#10;                    {&#10;                        Background = issue.Type == BuildIssueType.Error&#10;                            ? new SolidColorBrush(Color.FromArgb(30, 255, 0, 0)) // 红色半透明&#10;                            : new SolidColorBrush(Color.FromArgb(30, 255, 255, 0)), // 黄色半透明&#10;                        CornerRadius = new CornerRadius(4),&#10;                        Padding = new Thickness(10),&#10;                        Margin = new Thickness(0, 1, 0, 1)&#10;                    };&#10;&#10;                    var grid = new Grid();&#10;                    grid.ColumnDefinitions.Add(new ColumnDefinition { Width = GridLength.Auto });&#10;                    grid.ColumnDefinitions.Add(new ColumnDefinition { Width = new GridLength(1, GridUnitType.Star) });&#10;                    grid.ColumnDefinitions.Add(new ColumnDefinition { Width = GridLength.Auto });&#10;&#10;                    // 错误/警告图标&#10;                    var icon = new FontIcon&#10;                    {&#10;                        Glyph = issue.Type == BuildIssueType.Error ? &quot;\uE783&quot; : &quot;\uE7BA&quot;,&#10;                        FontSize = 14,&#10;                        Foreground = issue.Type == BuildIssueType.Error&#10;                            ? new SolidColorBrush(Colors.Red)&#10;                            : new SolidColorBrush(Colors.Orange),&#10;                        VerticalAlignment = VerticalAlignment.Top,&#10;                        Margin = new Thickness(0, 0, 8, 0)&#10;                    };&#10;                    Grid.SetColumn(icon, 0);&#10;                    grid.Children.Add(icon);&#10;&#10;                    // 消息内容&#10;                    var contentPanel = new StackPanel();&#10;&#10;                    var messageText = new TextBlock&#10;                    {&#10;                        Text = issue.Message,&#10;                        TextWrapping = TextWrapping.Wrap,&#10;                        FontSize = 13,&#10;                        Foreground = issue.Type == BuildIssueType.Error&#10;                            ? new SolidColorBrush(Colors.Red)&#10;                            : new SolidColorBrush(Colors.Orange)&#10;                    };&#10;                    contentPanel.Children.Add(messageText);&#10;&#10;                    var detailsPanel = new StackPanel&#10;                    {&#10;                        Orientation = Orientation.Horizontal,&#10;                        Spacing = 10,&#10;                        Margin = new Thickness(0, 5, 0, 0)&#10;                    };&#10;&#10;                    if (!string.IsNullOrEmpty(issue.SourceFile))&#10;                    {&#10;                        var fileText = new TextBlock&#10;                        {&#10;                            Text = issue.LineNumber &gt; 0 ? $&quot;{issue.SourceFile}:{issue.LineNumber}&quot; : issue.SourceFile,&#10;                            FontSize = 11,&#10;                            Foreground = new SolidColorBrush(Colors.Gray),&#10;                            FontFamily = new FontFamily(&quot;Consolas&quot;)&#10;                        };&#10;                        detailsPanel.Children.Add(fileText);&#10;                    }&#10;&#10;                    var engineText = new TextBlock&#10;                    {&#10;                        Text = issue.Engine,&#10;                        FontSize = 11,&#10;                        Foreground = new SolidColorBrush(Colors.Gray)&#10;                    };&#10;                    detailsPanel.Children.Add(engineText);&#10;&#10;                    contentPanel.Children.Add(detailsPanel);&#10;                    Grid.SetColumn(contentPanel, 1);&#10;                    grid.Children.Add(contentPanel);&#10;&#10;                    // 时间戳&#10;                    var timeText = new TextBlock&#10;                    {&#10;                        Text = issue.Timestamp.ToString(&quot;HH:mm:ss&quot;),&#10;                        FontSize = 11,&#10;                        Foreground = new SolidColorBrush(Colors.Gray),&#10;                        VerticalAlignment = VerticalAlignment.Top&#10;                    };&#10;                    Grid.SetColumn(timeText, 2);&#10;                    grid.Children.Add(timeText);&#10;&#10;                    border.Child = grid;&#10;&#10;                    // 如果这是第一个问题，移除占位符文本&#10;                    if (IssuesListPanel.Children.Count == 1 &amp;&amp;&#10;                        IssuesListPanel.Children[0] is TextBlock placeholder &amp;&amp;&#10;                        placeholder.Text == &quot;暂无错误或警告&quot;)&#10;                    {&#10;                        IssuesListPanel.Children.Clear();&#10;                    }&#10;&#10;                    IssuesListPanel.Children.Insert(0, border); // 最新的问题显示在顶部&#10;&#10;                    // 自动滚动到顶部显示最新问题&#10;                    IssuesScrollViewer.ScrollToVerticalOffset(0);&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    System.Diagnostics.Debug.WriteLine($&quot;AddIssueToList error: {ex.Message}&quot;);&#10;                }&#10;            });&#10;        }&#10;&#10;        private void UpdateIssuesCounts()&#10;        {&#10;            // 确保在 UI 线程上执行，并检查控件是否已初始化&#10;            DispatcherQueue.TryEnqueue(() =&gt;&#10;            {&#10;                try&#10;                {&#10;                    if (ErrorCountText != null &amp;&amp; WarningCountText != null)&#10;                    {&#10;                        ErrorCountText.Text = _errorCount.ToString();&#10;                        WarningCountText.Text = _warningCount.ToString();&#10;                    }&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    System.Diagnostics.Debug.WriteLine($&quot;UpdateIssuesCounts error: {ex.Message}&quot;);&#10;                }&#10;            });&#10;        }&#10;&#10;&#10;        private void ShowIssuesCard()&#10;        {&#10;            DispatcherQueue.TryEnqueue(() =&gt;&#10;            {&#10;                IssuesCard.Visibility = Visibility.Visible;&#10;            });&#10;        }&#10;&#10;        private void UpdateCurrentEngineInfo(UnrealEngineInfo engine, string step = &quot;准备中...&quot;)&#10;        {&#10;            DispatcherQueue.TryEnqueue(() =&gt;&#10;            {&#10;                try&#10;                {&#10;                    _currentBuildingEngine = engine;&#10;                    BuildStatusCard.Visibility = Visibility.Visible;&#10;&#10;                    CurrentEngineNameText.Text = $&quot;当前引擎: {engine?.DisplayName ?? &quot;未知&quot;}&quot;;&#10;                    CurrentEngineVersionText.Text = engine != null&#10;                        ? $&quot;版本: {engine.FullVersion ?? engine.Version ?? &quot;未知&quot;} | 路径: {Path.GetFileName(engine.EnginePath)}&quot;&#10;                        : &quot;&quot;;&#10;                    CurrentBuildStepText.Text = step;&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    System.Diagnostics.Debug.WriteLine($&quot;UpdateCurrentEngineInfo error: {ex.Message}&quot;);&#10;                }&#10;            });&#10;        }&#10;&#10;        private void UpdateBuildProgress(int percentage, string step = null)&#10;        {&#10;            DispatcherQueue.TryEnqueue(() =&gt;&#10;            {&#10;                try&#10;                {&#10;                    CurrentBuildProgressBar.Value = percentage;&#10;                    BuildProgressText.Text = $&quot;{percentage}%&quot;;&#10;&#10;                    if (!string.IsNullOrEmpty(step))&#10;                    {&#10;                        CurrentBuildStepText.Text = step;&#10;                    }&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    System.Diagnostics.Debug.WriteLine($&quot;UpdateBuildProgress error: {ex.Message}&quot;);&#10;                }&#10;            });&#10;        }&#10;&#10;        private void ClearTerminal()&#10;        {&#10;            DispatcherQueue.TryEnqueue(() =&gt;&#10;            {&#10;                try&#10;                {&#10;                    TerminalOutput.Blocks.Clear();&#10;                    var paragraph = new Paragraph();&#10;                    var run = new Run { Text = &quot;终端已清空&quot; };&#10;                    run.Foreground = new SolidColorBrush(Colors.Green);&#10;                    paragraph.Inlines.Add(run);&#10;                    TerminalOutput.Blocks.Add(paragraph);&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    System.Diagnostics.Debug.WriteLine($&quot;ClearTerminal error: {ex.Message}&quot;);&#10;                }&#10;            });&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region 事件处理&#10;&#10;        private void BuildModeRadio_Checked(object sender, RoutedEventArgs e)&#10;        {&#10;            try&#10;            {&#10;                if (SingleBuildRadio?.IsChecked == true)&#10;                {&#10;                    if (SingleBuildPanel != null) SingleBuildPanel.Visibility = Visibility.Visible;&#10;                    if (BatchBuildPanel != null) BatchBuildPanel.Visibility = Visibility.Collapsed;&#10;                    if (BatchProgressPanel != null) BatchProgressPanel.Visibility = Visibility.Collapsed;&#10;                }&#10;                else if (BatchBuildRadio?.IsChecked == true)&#10;                {&#10;                    if (SingleBuildPanel != null) SingleBuildPanel.Visibility = Visibility.Collapsed;&#10;                    if (BatchBuildPanel != null) BatchBuildPanel.Visibility = Visibility.Visible;&#10;                    if (BatchProgressPanel != null) BatchProgressPanel.Visibility = Visibility.Visible;&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;切换构建模式时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;            }&#10;        }&#10;&#10;        private void SelectAllEngines_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            foreach (var checkBox in _engineCheckBoxes)&#10;                checkBox.IsChecked = true;&#10;        }&#10;&#10;        private void DeselectAllEngines_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            foreach (var checkBox in _engineCheckBoxes)&#10;                checkBox.IsChecked = false;&#10;        }&#10;&#10;        private void SelectUE5Only_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            foreach (var checkBox in _engineCheckBoxes)&#10;            {&#10;                var engine = checkBox.Tag as UnrealEngineInfo;&#10;                checkBox.IsChecked = engine?.BuildVersionInfo?.MajorVersion == 5;&#10;            }&#10;        }&#10;&#10;        private void ClearIssues_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            _buildIssues.Clear();&#10;            _errorCount = 0;&#10;            _warningCount = 0;&#10;&#10;            IssuesListPanel.Children.Clear();&#10;            var placeholder = new TextBlock&#10;            {&#10;                Text = &quot;暂无错误或警告&quot;,&#10;                Foreground = new SolidColorBrush(Colors.Gray),&#10;                FontStyle = Windows.UI.Text.FontStyle.Italic,&#10;                HorizontalAlignment = HorizontalAlignment.Center,&#10;                Margin = new Thickness(0, 20, 0, 20)&#10;            };&#10;            IssuesListPanel.Children.Add(placeholder);&#10;&#10;            UpdateIssuesCounts();&#10;            WriteToTerminal(&quot;已清空错误和警告列表&quot;, TerminalMessageType.Info);&#10;        }&#10;&#10;        private void ToggleIssues_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            if (IssuesScrollViewer.Visibility == Visibility.Visible)&#10;            {&#10;                IssuesScrollViewer.Visibility = Visibility.Collapsed;&#10;                CollapseIssuesButton.Content = &quot;展开&quot;;&#10;            }&#10;            else&#10;            {&#10;                IssuesScrollViewer.Visibility = Visibility.Visible;&#10;                CollapseIssuesButton.Content = &quot;收起&quot;;&#10;            }&#10;        }&#10;&#10;        private void ClearTerminal_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            ClearTerminal();&#10;        }&#10;&#10;        private void ScrollToBottom_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            TerminalScrollViewer.ScrollToVerticalOffset(TerminalScrollViewer.ExtentHeight);&#10;        }&#10;&#10;        // ... 其他事件处理方法保持不变 ...&#10;&#10;        #endregion&#10;&#10;        #region 构建方法&#10;&#10;        private async void StartBuild_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            if (_isBuildInProgress)&#10;                return;&#10;&#10;            if (!ValidateInputs())&#10;                return;&#10;&#10;            // 清空之前的问题列表&#10;            ClearIssues_Click(null, null);&#10;&#10;            _isBuildInProgress = true;&#10;            _buildCancellationTokenSource = new CancellationTokenSource();&#10;&#10;            StartBuildButton.IsEnabled = false;&#10;            StopBuildButton.IsEnabled = true;&#10;&#10;            // 更新导航栏状态：开始构建&#10;            UpdateNavigationStatus(true, 1, &quot;插件构建中...&quot;);&#10;&#10;            WriteToTerminal(&quot;=== 开始插件构建 ===&quot;, TerminalMessageType.Success);&#10;&#10;            // 显示插件详细信息&#10;            if (_currentPluginInfo != null)&#10;            {&#10;                WriteToTerminal($&quot;插件名称: {_currentPluginInfo.GetDisplayName()}&quot;, TerminalMessageType.Info);&#10;                WriteToTerminal($&quot;插件版本: {_currentPluginInfo.GetVersionString()}&quot;, TerminalMessageType.Info);&#10;                WriteToTerminal($&quot;作者: {_currentPluginInfo.CreatedBy ?? &quot;未知&quot;}&quot;, TerminalMessageType.Info);&#10;                WriteToTerminal($&quot;模块数量: {_currentPluginInfo.GetModuleCount()}&quot;, TerminalMessageType.Info);&#10;            }&#10;&#10;            try&#10;            {&#10;                if (SingleBuildRadio.IsChecked == true)&#10;                {&#10;                    await PerformSingleBuildAsync(_buildCancellationTokenSource.Token);&#10;                }&#10;                else&#10;                {&#10;                    // 批量构建&#10;                    var selectedEngines = GetSelectedEnginesForBatch();&#10;                    UpdateNavigationStatus(true, selectedEngines.Count, $&quot;批量构建中 (共{selectedEngines.Count}个引擎)&quot;);&#10;                    await PerformBatchBuildAsync(_buildCancellationTokenSource.Token);&#10;                }&#10;&#10;                // 构建成功完成&#10;                UpdateNavigationStatus(false, 0, &quot;构建完成&quot;);&#10;                WriteToTerminal(&quot;=== 构建成功完成 ===&quot;, TerminalMessageType.Success);&#10;            }&#10;            catch (OperationCanceledException)&#10;            {&#10;                WriteToTerminal(&quot;构建已被用户取消&quot;, TerminalMessageType.Warning);&#10;                UpdateNavigationStatus(false, 0, &quot;构建已取消&quot;);&#10;                UpdateCurrentEngineInfo(null, &quot;已取消&quot;);&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;构建过程中发生错误: {ex.Message}&quot;, TerminalMessageType.Error);&#10;                UpdateNavigationStatus(false, 0, $&quot;构建失败: {ex.Message}&quot;);&#10;                UpdateCurrentEngineInfo(null, &quot;构建失败&quot;);&#10;            }&#10;            finally&#10;            {&#10;                _isBuildInProgress = false;&#10;                StartBuildButton.IsEnabled = true;&#10;                StopBuildButton.IsEnabled = false;&#10;                _buildCancellationTokenSource?.Dispose();&#10;                _buildCancellationTokenSource = null;&#10;                BuildStatusCard.Visibility = Visibility.Collapsed;&#10;&#10;                // 延迟3秒后清除状态&#10;                await Task.Delay(3000);&#10;                if (!_isBuildInProgress) // 确保没有新的构建开始&#10;                {&#10;                    UpdateNavigationStatus(false, 0, &quot;就绪&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;&#10;        private async Task PerformSingleBuildAsync(CancellationToken cancellationToken)&#10;        {&#10;            var engine = GetSelectedEngine();&#10;            UpdateCurrentEngineInfo(engine, &quot;开始构建&quot;);&#10;            await ExecuteRunUATCommand(engine, cancellationToken);&#10;        }&#10;&#10;        private async Task PerformBatchBuildAsync(CancellationToken cancellationToken)&#10;        {&#10;            _selectedEnginesForBatch = GetSelectedEnginesForBatch();&#10;            _batchBuildResults = new List&lt;string&gt;();&#10;&#10;            WriteToTerminal($&quot;开始批量构建，共 {_selectedEnginesForBatch.Count} 个引擎版本&quot;, TerminalMessageType.Info);&#10;&#10;            // 更新为批量构建状态&#10;            UpdateNavigationStatus(true, _selectedEnginesForBatch.Count, $&quot;批量构建 (0/{_selectedEnginesForBatch.Count})&quot;);&#10;&#10;            for (int i = 0; i &lt; _selectedEnginesForBatch.Count; i++)&#10;            {&#10;                var engine = _selectedEnginesForBatch[i];&#10;&#10;                // 更新批量构建进度&#10;                UpdateNavigationStatus(true, _selectedEnginesForBatch.Count, $&quot;批量构建 ({i + 1}/{_selectedEnginesForBatch.Count})&quot;);&#10;&#10;                UpdateBatchProgress($&quot;构建 {engine.DisplayName} ({i + 1}/{_selectedEnginesForBatch.Count})&quot;,&#10;                    i, _selectedEnginesForBatch.Count);&#10;&#10;                UpdateCurrentEngineInfo(engine, $&quot;批量构建 {i + 1}/{_selectedEnginesForBatch.Count}&quot;);&#10;&#10;                WriteToTerminal($&quot;=== 开始构建 {engine.DisplayName} ({engine.FullVersion ?? engine.Version}) ===&quot;, TerminalMessageType.Info);&#10;&#10;                try&#10;                {&#10;                    await ExecuteRunUATCommand(engine, cancellationToken);&#10;&#10;                    var result = $&quot;✓ {engine.DisplayName}: 构建成功&quot;;&#10;                    _batchBuildResults.Add(result);&#10;                    WriteToTerminal(result, TerminalMessageType.Success);&#10;                }&#10;                catch (OperationCanceledException)&#10;                {&#10;                    throw;&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    var result = $&quot;✗ {engine.DisplayName}: 构建失败 - {ex.Message}&quot;;&#10;                    _batchBuildResults.Add(result);&#10;                    WriteToTerminal(result, TerminalMessageType.Error);&#10;&#10;                    if (StopOnErrorCheckBox.IsChecked.GetValueOrDefault())&#10;                    {&#10;                        WriteToTerminal(&quot;根据设置，遇到错误时停止批量构建&quot;, TerminalMessageType.Warning);&#10;                        UpdateNavigationStatus(true, 1, &quot;批量构建因错误停止&quot;);&#10;                        break;&#10;                    }&#10;                }&#10;            }&#10;&#10;            // 显示批量构建结果摘要&#10;            WriteToTerminal(&quot;=== 批量构建完成 ===&quot;, TerminalMessageType.Info);&#10;            foreach (var result in _batchBuildResults)&#10;            {&#10;                WriteToTerminal(result, result.StartsWith(&quot;✓&quot;) ? TerminalMessageType.Success : TerminalMessageType.Error);&#10;            }&#10;&#10;            var successCount = _batchBuildResults.Count(r =&gt; r.StartsWith(&quot;✓&quot;));&#10;            var failCount = _batchBuildResults.Count(r =&gt; r.StartsWith(&quot;✗&quot;));&#10;&#10;            UpdateBatchProgress($&quot;批量构建完成: {successCount} 成功, {failCount} 失败&quot;,&#10;                _selectedEnginesForBatch.Count, _selectedEnginesForBatch.Count);&#10;&#10;            UpdateCurrentEngineInfo(null, &quot;批量构建完成&quot;);&#10;&#10;            // 更新最终状态&#10;            if (failCount &gt; 0)&#10;            {&#10;                UpdateNavigationStatus(false, 0, $&quot;批量构建完成: {successCount}成功 {failCount}失败&quot;);&#10;            }&#10;            else&#10;            {&#10;                UpdateNavigationStatus(false, 0, $&quot;批量构建完成: 全部{successCount}个成功&quot;);&#10;            }&#10;        }&#10;&#10;&#10;        private async Task ExecuteRunUATCommand(UnrealEngineInfo engine, CancellationToken cancellationToken)&#10;        {&#10;            UpdateCurrentEngineInfo(engine, &quot;验证引擎配置&quot;);&#10;            // 更新具体的引擎构建状态&#10;            UpdateNavigationStatus(true, 1, $&quot;构建 {engine.DisplayName}&quot;);&#10;&#10;            WriteToTerminal($&quot;验证引擎配置: {engine.DisplayName}&quot;, TerminalMessageType.Info);&#10;&#10;            var runUATPath = Path.Combine(engine.EnginePath, &quot;Engine&quot;, &quot;Build&quot;, &quot;BatchFiles&quot;, &quot;RunUAT.bat&quot;);&#10;            if (!File.Exists(runUATPath))&#10;            {&#10;                throw new Exception($&quot;RunUAT.bat 不存在: {runUATPath}&quot;);&#10;            }&#10;&#10;            WriteToTerminal($&quot;RunUAT.bat 路径: {runUATPath}&quot;, TerminalMessageType.Info);&#10;&#10;            var outputPath = GetFinalOutputPath(engine);&#10;            Directory.CreateDirectory(outputPath);&#10;&#10;            var command = BuildRunUATCommand(engine);&#10;            WriteToTerminal($&quot;执行命令: {command}&quot;, TerminalMessageType.Command);&#10;&#10;            UpdateCurrentEngineInfo(engine, &quot;启动 UAT 构建进程&quot;);&#10;            UpdateBuildProgress(10, &quot;启动构建进程&quot;);&#10;            // 更新导航状态为正在编译&#10;            UpdateNavigationStatus(true, 1, $&quot;正在编译 {engine.DisplayName}&quot;);&#10;&#10;            var processInfo = new ProcessStartInfo&#10;            {&#10;                FileName = &quot;cmd.exe&quot;,&#10;                Arguments = $&quot;/c \&quot;{command}\&quot;&quot;,&#10;                UseShellExecute = false,&#10;                RedirectStandardOutput = true,&#10;                RedirectStandardError = true,&#10;                CreateNoWindow = true,&#10;                StandardOutputEncoding = Encoding.UTF8,&#10;                StandardErrorEncoding = Encoding.UTF8,&#10;                WorkingDirectory = Path.GetDirectoryName(runUATPath)&#10;            };&#10;&#10;            _currentProcess = new Process { StartInfo = processInfo };&#10;&#10;            _currentProcess.OutputDataReceived += (sender, args) =&gt;&#10;            {&#10;                if (!string.IsNullOrEmpty(args.Data))&#10;                {&#10;                    WriteToTerminal(args.Data, TerminalMessageType.Info);&#10;                    UpdateBuildProgressFromOutput(args.Data);&#10;                    UpdateNavigationStatusFromOutput(args.Data, engine);&#10;                }&#10;            };&#10;&#10;            _currentProcess.ErrorDataReceived += (sender, args) =&gt;&#10;            {&#10;                if (!string.IsNullOrEmpty(args.Data))&#10;                {&#10;                    WriteToTerminal(args.Data, TerminalMessageType.Error);&#10;                    // 检查是否是严重错误&#10;                    if (IsRealError(args.Data, TerminalMessageType.Error))&#10;                    {&#10;                        UpdateNavigationStatus(true, 1, $&quot;构建错误: {engine.DisplayName}&quot;);&#10;                    }&#10;                }&#10;            };&#10;&#10;            try&#10;            {&#10;                _currentProcess.Start();&#10;                _currentProcess.BeginOutputReadLine();&#10;                _currentProcess.BeginErrorReadLine();&#10;&#10;                while (!_currentProcess.HasExited)&#10;                {&#10;                    cancellationToken.ThrowIfCancellationRequested();&#10;                    await Task.Delay(500, cancellationToken);&#10;                }&#10;&#10;                _currentProcess.WaitForExit();&#10;&#10;                if (_currentProcess.ExitCode == 0)&#10;                {&#10;                    UpdateBuildProgress(100, &quot;构建完成&quot;);&#10;                    UpdateNavigationStatus(true, 1, $&quot;构建完成: {engine.DisplayName}&quot;);&#10;                    WriteToTerminal($&quot;=== {engine.DisplayName} 构建成功完成 ===&quot;, TerminalMessageType.Success);&#10;                    WriteToTerminal($&quot;输出路径: {outputPath}&quot;, TerminalMessageType.Success);&#10;                }&#10;                else&#10;                {&#10;                    UpdateBuildProgress(0, &quot;构建失败&quot;);&#10;                    UpdateNavigationStatus(true, 1, $&quot;构建失败: {engine.DisplayName}&quot;);&#10;                    throw new Exception($&quot;构建失败，退出代码: {_currentProcess.ExitCode}&quot;);&#10;                }&#10;            }&#10;            catch (OperationCanceledException)&#10;            {&#10;                if (_currentProcess != null &amp;&amp; !_currentProcess.HasExited)&#10;                {&#10;                    _currentProcess.Kill();&#10;                    WriteToTerminal(&quot;构建进程已被终止&quot;, TerminalMessageType.Warning);&#10;                    UpdateNavigationStatus(false, 0, &quot;构建已取消&quot;);&#10;                }&#10;&#10;                throw;&#10;            }&#10;            finally&#10;            {&#10;                _currentProcess?.Dispose();&#10;                _currentProcess = null;&#10;            }&#10;        }&#10;&#10;&#10;        private void UpdateBuildProgressFromOutput(string output)&#10;        {&#10;            try&#10;            {&#10;                var lowerOutput = output.ToLower();&#10;&#10;                if (lowerOutput.Contains(&quot;parsing&quot;) || lowerOutput.Contains(&quot;loading&quot;))&#10;                {&#10;                    UpdateBuildProgress(20, &quot;解析项目文件&quot;);&#10;                }&#10;                else if (lowerOutput.Contains(&quot;compiling&quot;) || lowerOutput.Contains(&quot;building&quot;))&#10;                {&#10;                    UpdateBuildProgress(50, &quot;正在编译插件&quot;);&#10;                }&#10;                else if (lowerOutput.Contains(&quot;linking&quot;))&#10;                {&#10;                    UpdateBuildProgress(70, &quot;正在链接&quot;);&#10;                }&#10;                else if (lowerOutput.Contains(&quot;packaging&quot;) || lowerOutput.Contains(&quot;copying&quot;))&#10;                {&#10;                    UpdateBuildProgress(80, &quot;正在打包插件&quot;);&#10;                }&#10;                else if (lowerOutput.Contains(&quot;success&quot;) || lowerOutput.Contains(&quot;completed&quot;))&#10;                {&#10;                    UpdateBuildProgress(90, &quot;构建接近完成&quot;);&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                System.Diagnostics.Debug.WriteLine($&quot;UpdateBuildProgressFromOutput error: {ex.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        // ... 其他方法保持不变，但需要添加一些事件处理 ...&#10;&#10;        private async void BrowseSourcePath_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            try&#10;            {&#10;                var filePicker = new FileOpenPicker();&#10;                filePicker.SuggestedStartLocation = PickerLocationId.Desktop;&#10;                filePicker.FileTypeFilter.Add(&quot;.uplugin&quot;);&#10;&#10;                var window = App.MainWindow;&#10;                if (window != null)&#10;                {&#10;                    var hwnd = WinRT.Interop.WindowNative.GetWindowHandle(window);&#10;                    WinRT.Interop.InitializeWithWindow.Initialize(filePicker, hwnd);&#10;                }&#10;&#10;                var file = await filePicker.PickSingleFileAsync();&#10;                if (file != null)&#10;                {&#10;                    SourcePathTextBox.Text = file.Path;&#10;                    WriteToTerminal($&quot;已选择插件文件: {file.Path}&quot;, TerminalMessageType.Success);&#10;                    await LoadPluginInfo(file.Path);&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;选择插件文件时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;            }&#10;        }&#10;&#10;        private async void BrowseOutputPath_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            try&#10;            {&#10;                var folderPicker = new FolderPicker();&#10;                folderPicker.SuggestedStartLocation = PickerLocationId.Desktop;&#10;                folderPicker.FileTypeFilter.Add(&quot;*&quot;);&#10;&#10;                var window = App.MainWindow;&#10;                if (window != null)&#10;                {&#10;                    var hwnd = WinRT.Interop.WindowNative.GetWindowHandle(window);&#10;                    WinRT.Interop.InitializeWithWindow.Initialize(folderPicker, hwnd);&#10;                }&#10;&#10;                var folder = await folderPicker.PickSingleFolderAsync();&#10;                if (folder != null)&#10;                {&#10;                    OutputPathTextBox.Text = folder.Path;&#10;                    WriteToTerminal($&quot;已选择输出路径: {folder.Path}&quot;, TerminalMessageType.Success);&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;选择输出路径时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;            }&#10;        }&#10;&#10;        private void PreviewCommand_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            try&#10;            {&#10;                if (!ValidateInputs())&#10;                    return;&#10;&#10;                var commands = new List&lt;string&gt;();&#10;&#10;                if (SingleBuildRadio.IsChecked == true)&#10;                {&#10;                    var engine = GetSelectedEngine();&#10;                    var command = BuildRunUATCommand(engine);&#10;                    commands.Add(command);&#10;                }&#10;                else&#10;                {&#10;                    var engines = GetSelectedEnginesForBatch();&#10;                    foreach (var engine in engines)&#10;                    {&#10;                        var command = BuildRunUATCommand(engine);&#10;                        commands.Add($&quot;# {engine.DisplayName}:&quot;);&#10;                        commands.Add(command);&#10;                        commands.Add(&quot;&quot;);&#10;                    }&#10;                }&#10;&#10;                CommandPreviewText.Text = string.Join(&quot;\n\n&quot;, commands);&#10;                CommandPreviewPanel.Visibility = Visibility.Visible;&#10;                WriteToTerminal(&quot;已生成构建命令预览&quot;, TerminalMessageType.Info);&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;生成命令预览时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;            }&#10;        }&#10;&#10;        private void OpenOutput_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            try&#10;            {&#10;                var outputPath = OutputPathTextBox.Text;&#10;                if (Directory.Exists(outputPath))&#10;                {&#10;                    Process.Start(&quot;explorer.exe&quot;, outputPath);&#10;                    WriteToTerminal($&quot;已打开输出目录: {outputPath}&quot;, TerminalMessageType.Success);&#10;                }&#10;                else&#10;                {&#10;                    WriteToTerminal($&quot;输出目录不存在: {outputPath}&quot;, TerminalMessageType.Warning);&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;打开输出目录时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;            }&#10;        }&#10;&#10;        private void StopBuild_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            try&#10;            {&#10;                if (_buildCancellationTokenSource != null &amp;&amp; !_buildCancellationTokenSource.Token.IsCancellationRequested)&#10;                {&#10;                    _buildCancellationTokenSource.Cancel();&#10;&#10;                    if (_currentProcess != null &amp;&amp; !_currentProcess.HasExited)&#10;                    {&#10;                        _currentProcess.Kill();&#10;                        WriteToTerminal(&quot;正在强制终止构建进程...&quot;, TerminalMessageType.Warning);&#10;                    }&#10;&#10;                    WriteToTerminal(&quot;正在取消构建...&quot;, TerminalMessageType.Warning);&#10;                    UpdateCurrentEngineInfo(_currentBuildingEngine, &quot;正在取消...&quot;);&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;取消构建时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;            }&#10;        }&#10;&#10;        // 添加终端大小调整的事件处理&#10;        private void TerminalSizeComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)&#10;        {&#10;            try&#10;            {&#10;                if (sender is ComboBox comboBox &amp;&amp; comboBox.SelectedItem is ComboBoxItem selectedItem)&#10;                {&#10;                    if (int.TryParse(selectedItem.Tag?.ToString(), out int height))&#10;                    {&#10;                        // 确保 TerminalScrollViewer 已经初始化&#10;                        if (TerminalScrollViewer != null)&#10;                        {&#10;                            TerminalScrollViewer.Height = height;&#10;&#10;                            // 只有在页面完全加载后才显示调整消息&#10;                            if (this.IsLoaded)&#10;                            {&#10;                                WriteToTerminal($&quot;终端高度已调整为 {height}px&quot;, TerminalMessageType.Info);&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                System.Diagnostics.Debug.WriteLine($&quot;调整终端大小时出错: {ex.Message}&quot;);&#10;                // 不在初始化时显示错误，避免循环调用&#10;            }&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region 导航状态管理&#10;&#10;        /// &lt;summary&gt;&#10;        /// 更新导航栏中的 InfoBadge 状态&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;isActive&quot;&gt;是否有活动任务&lt;/param&gt;&#10;        /// &lt;param name=&quot;taskCount&quot;&gt;任务数量&lt;/param&gt;&#10;        /// &lt;param name=&quot;statusText&quot;&gt;状态文本&lt;/param&gt;&#10;        private void UpdateNavigationStatus(bool isActive, int taskCount, string statusText)&#10;        {&#10;            try&#10;            {&#10;                // 使用全局状态服务更新&#10;                if (isActive)&#10;                {&#10;                    Services.PluginsBuildStatusService.Instance.UpdateStatus(isActive, taskCount, statusText);&#10;                }&#10;                else&#10;                {&#10;                    Services.PluginsBuildStatusService.Instance.UpdateStatus(false, 0, statusText);&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                System.Diagnostics.Debug.WriteLine($&quot;UpdateNavigationStatus error: {ex.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// 根据构建输出更新导航状态&#10;        /// &lt;/summary&gt;&#10;        private void UpdateNavigationStatusFromOutput(string output, UnrealEngineInfo engine)&#10;        {&#10;            try&#10;            {&#10;                var lowerOutput = output.ToLower();&#10;&#10;                if (lowerOutput.Contains(&quot;parsing&quot;) || lowerOutput.Contains(&quot;loading&quot;))&#10;                {&#10;                    UpdateNavigationStatus(true, 1, $&quot;解析项目: {engine.DisplayName}&quot;);&#10;                }&#10;                else if (lowerMessage.Contains(&quot;compiling&quot;) || lowerMessage.Contains(&quot;building&quot;))&#10;                {&#10;                    UpdateNavigationStatus(true, 1, $&quot;正在编译: {engine.DisplayName}&quot;);&#10;                }&#10;                else if (lowerOutput.Contains(&quot;linking&quot;))&#10;                {&#10;                    UpdateNavigationStatus(true, 1, $&quot;正在链接: {engine.DisplayName}&quot;);&#10;                }&#10;                else if (lowerOutput.Contains(&quot;packaging&quot;) || lowerOutput.Contains(&quot;copying&quot;))&#10;                {&#10;                    UpdateNavigationStatus(true, 1, $&quot;正在打包: {engine.DisplayName}&quot;);&#10;                }&#10;                else if (lowerOutput.Contains(&quot;success&quot;) || lowerOutput.Contains(&quot;completed&quot;))&#10;                {&#10;                    UpdateNavigationStatus(true, 1, $&quot;即将完成: {engine.DisplayName}&quot;);&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                System.Diagnostics.Debug.WriteLine($&quot;UpdateNavigationStatusFromOutput error: {ex.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        #endregion&#10;&#10;&#10;        #region 辅助方法&#10;&#10;        // 包括: LoadPluginInfo, DisplayPluginInfo, ValidateInputs, GetSelectedEngine, &#10;        // GetSelectedEnginesForBatch, BuildRunUATCommand, GetFinalOutputPath, &#10;        // GetSelectedBuildType, GetSelectedPlatforms, UpdateBatchProgress 等&#10;&#10;        private async Task LoadPluginInfo(string pluginPath)&#10;        {&#10;            try&#10;            {&#10;                if (!File.Exists(pluginPath) || !pluginPath.EndsWith(&quot;.uplugin&quot;))&#10;                {&#10;                    WriteToTerminal(&quot;错误: 请选择有效的 .uplugin 文件&quot;, TerminalMessageType.Error);&#10;                    return;&#10;                }&#10;&#10;                var content = await File.ReadAllTextAsync(pluginPath, Encoding.UTF8);&#10;                _currentPluginInfo = JsonSerializer.Deserialize&lt;PluginInfo&gt;(content, new JsonSerializerOptions&#10;                {&#10;                    PropertyNameCaseInsensitive = true&#10;                });&#10;&#10;                if (_currentPluginInfo != null)&#10;                {&#10;                    DisplayPluginInfo(_currentPluginInfo);&#10;                    WriteToTerminal($&quot;成功解析插件信息: {_currentPluginInfo.GetDisplayName()} v{_currentPluginInfo.GetVersionString()}&quot;, TerminalMessageType.Success);&#10;                }&#10;                else&#10;                {&#10;                    WriteToTerminal(&quot;警告: 无法解析插件文件内容&quot;, TerminalMessageType.Warning);&#10;                }&#10;            }&#10;            catch (JsonException ex)&#10;            {&#10;                WriteToTerminal($&quot;解析插件文件失败: {ex.Message}&quot;, TerminalMessageType.Error);&#10;                _currentPluginInfo = null;&#10;                HidePluginInfo();&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;读取插件文件时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;                _currentPluginInfo = null;&#10;                HidePluginInfo();&#10;            }&#10;        }&#10;&#10;        private bool ShouldFilterMessage(string message)&#10;        {&#10;            // 过滤一些噪音消息&#10;            var noisePatterns = new[]&#10;            {&#10;                @&quot;^LogTemp:\s*Display:&quot;,&#10;                @&quot;^LogInit:\s*Display:&quot;,&#10;                @&quot;^LogCore:\s*Display:&quot;,&#10;                @&quot;^LogEngine:\s*Display:&quot;,&#10;                @&quot;^LogOutputDevice:&quot;,&#10;                @&quot;^LogModuleManager:&quot;,&#10;                @&quot;^LogWindows:&quot;,&#10;                @&quot;Reading BuildConfiguration&quot;,&#10;                @&quot;Executing actions \(\d+ in parallel\)&quot;,&#10;                @&quot;^\s*$&quot;, // 空行&#10;                @&quot;^Running Internal UnrealHeaderTool.*-WarningsAsErrors -installed$&quot;,&#10;                @&quot;Determining max actions to execute&quot;,&#10;                @&quot;Building UnrealHeaderTool&quot;,&#10;                @&quot;Parsing headers for&quot;,&#10;                @&quot;Generated code for target&quot;,&#10;                @&quot;Total execution time:&quot;&#10;            };&#10;&#10;            return noisePatterns.Any(pattern =&gt;&#10;                System.Text.RegularExpressions.Regex.IsMatch(message, pattern, System.Text.RegularExpressions.RegexOptions.IgnoreCase));&#10;        }&#10;&#10;&#10;        private void DisplayPluginInfo(PluginInfo pluginInfo)&#10;        {&#10;            try&#10;            {&#10;                PluginInfoPanel.Visibility = Visibility.Visible;&#10;&#10;                PluginFriendlyNameText.Text = pluginInfo.GetDisplayName();&#10;                PluginVersionText.Text = pluginInfo.GetVersionString();&#10;                PluginDescriptionText.Text = string.IsNullOrEmpty(pluginInfo.Description) ? &quot;无描述&quot; : pluginInfo.Description;&#10;                PluginCreatedByText.Text = string.IsNullOrEmpty(pluginInfo.CreatedBy) ? &quot;未知&quot; : pluginInfo.CreatedBy;&#10;&#10;                var moduleInfos = new List&lt;string&gt;();&#10;                if (pluginInfo.Modules?.Count &gt; 0)&#10;                {&#10;                    var runtimeModules = pluginInfo.Modules.Count(m =&gt; m.Type == &quot;Runtime&quot; || m.Type == &quot;RuntimeAndProgram&quot;);&#10;                    var editorModules = pluginInfo.Modules.Count(m =&gt; m.Type == &quot;Editor&quot; || m.Type == &quot;UncookedOnly&quot;);&#10;                    var otherModules = pluginInfo.Modules.Count - runtimeModules - editorModules;&#10;&#10;                    if (runtimeModules &gt; 0) moduleInfos.Add($&quot;{runtimeModules} 运行时&quot;);&#10;                    if (editorModules &gt; 0) moduleInfos.Add($&quot;{editorModules} 编辑器&quot;);&#10;                    if (otherModules &gt; 0) moduleInfos.Add($&quot;{otherModules} 其他&quot;);&#10;&#10;                    moduleInfos.Add($&quot;(共 {pluginInfo.Modules.Count} 个模块)&quot;);&#10;                }&#10;                else&#10;                {&#10;                    moduleInfos.Add(&quot;无模块信息&quot;);&#10;                }&#10;&#10;                PluginModulesText.Text = string.Join(&quot;, &quot;, moduleInfos);&#10;&#10;                if (string.IsNullOrWhiteSpace(PluginNameTextBox.Text))&#10;                {&#10;                    PluginNameTextBox.PlaceholderText = $&quot;留空将使用: {pluginInfo.GetDisplayName()}&quot;;&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;显示插件信息时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;            }&#10;        }&#10;&#10;        private void HidePluginInfo()&#10;        {&#10;            try&#10;            {&#10;                PluginInfoPanel.Visibility = Visibility.Collapsed;&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                System.Diagnostics.Debug.WriteLine($&quot;HidePluginInfo error: {ex.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        // 在类的字段部分添加这些变量&#10;        // 错误过滤关键字列表&#10;        private readonly HashSet&lt;string&gt; _falseErrorKeywords = new HashSet&lt;string&gt;(StringComparer.OrdinalIgnoreCase)&#10;        {&#10;            &quot;Running Internal UnrealHeaderTool&quot;,&#10;            &quot;LogTemp:&quot;,&#10;            &quot;LogInit:&quot;,&#10;            &quot;LogCore:&quot;,&#10;            &quot;LogEngine:&quot;,&#10;            &quot;UATHelper:&quot;,&#10;            &quot;AutomationTool:&quot;,&#10;            &quot;BuildCommand.Execute:&quot;,&#10;            &quot;Program.Main:&quot;,&#10;            &quot;UnrealBuildTool.Main:&quot;,&#10;            &quot;LogModuleManager:&quot;,&#10;            &quot;LogOutputDevice:&quot;,&#10;            &quot;LogWindows:&quot;,&#10;            &quot;LogD3D11RHI:&quot;,&#10;            &quot;Reading BuildConfiguration&quot;,&#10;            &quot;Determining max actions&quot;,&#10;            &quot;Executing actions&quot;,&#10;            &quot;Building UnrealHeaderTool&quot;,&#10;            &quot;Parsing headers&quot;,&#10;            &quot;Generated code&quot;,&#10;            &quot;Total execution time&quot;&#10;        };&#10;&#10;        private bool IsFalseError(string message)&#10;        {&#10;            // 检查是否包含误报关键字&#10;            if (_falseErrorKeywords.Any(keyword =&gt; message.Contains(keyword, StringComparison.OrdinalIgnoreCase)))&#10;            {&#10;                return true;&#10;            }&#10;&#10;            // 检查特定模式&#10;            var patterns = new[]&#10;            {&#10;                @&quot;Running Internal UnrealHeaderTool.*\.uproject&quot;,&#10;                @&quot;LogTemp:\s*Display:&quot;,&#10;                @&quot;LogInit:\s*Display:&quot;,&#10;                @&quot;LogCore:\s*Display:&quot;,&#10;                @&quot;LogEngine:\s*Display:&quot;,&#10;                @&quot;UATHelper:\s*.*&quot;,&#10;                @&quot;AutomationTool:\s*.*&quot;,&#10;                @&quot;BuildCommand\.Execute:\s*.*&quot;,&#10;                @&quot;Program\.Main:\s*.*&quot;,&#10;                @&quot;Reading BuildConfiguration.*&quot;,&#10;                @&quot;Determining max actions.*&quot;,&#10;                @&quot;Executing actions.*&quot;,&#10;                @&quot;Building.*\.exe.*&quot;,&#10;                @&quot;Parsing headers.*&quot;,&#10;                @&quot;Generated code.*&quot;,&#10;                @&quot;Total execution time.*&quot;,&#10;                @&quot;LogModuleManager:\s*.*&quot;,&#10;                @&quot;LogOutputDevice:\s*.*&quot;&#10;            };&#10;&#10;            foreach (var pattern in patterns)&#10;            {&#10;                if (System.Text.RegularExpressions.Regex.IsMatch(message, pattern, System.Text.RegularExpressions.RegexOptions.IgnoreCase))&#10;                {&#10;                    return true;&#10;                }&#10;            }&#10;&#10;            return false;&#10;        }&#10;&#10;        private bool IsRealError(string message, TerminalMessageType messageType)&#10;        {&#10;            if (messageType == TerminalMessageType.Error)&#10;                return true;&#10;&#10;            var lowerMessage = message.ToLower();&#10;&#10;            // 真正的错误模式&#10;            var errorPatterns = new[]&#10;            {&#10;                @&quot;\berror\s*C\d+:&quot;,&#10;                @&quot;\berror\s*LNK\d+:&quot;,&#10;                @&quot;\berror\s*MSB\d+:&quot;,&#10;                @&quot;fatal\s*error:&quot;,&#10;                @&quot;compilation\s*failed&quot;,&#10;                @&quot;build\s*failed&quot;,&#10;                @&quot;failed\s*to\s*compile&quot;,&#10;                @&quot;unresolved\s*external\s*symbol&quot;,&#10;                @&quot;undefined\s*reference&quot;,&#10;                @&quot;syntax\s*error&quot;,&#10;                @&quot;parse\s*error&quot;,&#10;                @&quot;.*\.cpp\(\d+\):\s*error&quot;,&#10;                @&quot;.*\.h\(\d+\):\s*error&quot;,&#10;                @&quot;.*\.cs\(\d+\):\s*error&quot;,&#10;                @&quot;exception\s*thrown&quot;,&#10;                @&quot;access\s*violation&quot;,&#10;                @&quot;segmentation\s*fault&quot;&#10;            };&#10;&#10;            return errorPatterns.Any(pattern =&gt;&#10;                System.Text.RegularExpressions.Regex.IsMatch(message, pattern, System.Text.RegularExpressions.RegexOptions.IgnoreCase));&#10;        }&#10;&#10;        private bool IsRealWarning(string message, TerminalMessageType messageType)&#10;        {&#10;            if (messageType == TerminalMessageType.Warning)&#10;                return true;&#10;&#10;            var lowerMessage = message.ToLower();&#10;&#10;            // 真正的警告模式&#10;            var warningPatterns = new[]&#10;            {&#10;                @&quot;\bwarning\s*C\d+:&quot;,&#10;                @&quot;\bwarning\s*LNK\d+:&quot;,&#10;                @&quot;\bwarning\s*MSB\d+:&quot;,&#10;                @&quot;.*\.cpp\(\d+\):\s*warning&quot;,&#10;                @&quot;.*\.h\(\d+\):\s*warning&quot;,&#10;                @&quot;.*\.cs\(\d+\):\s*warning&quot;,&#10;                @&quot;deprecated&quot;,&#10;                @&quot;obsolete&quot;,&#10;                @&quot;unreachable\s*code&quot;,&#10;                @&quot;unused\s*variable&quot;,&#10;                @&quot;unused\s*parameter&quot;,&#10;                @&quot;conversion\s*warning&quot;,&#10;                @&quot;truncation\s*warning&quot;&#10;            };&#10;&#10;            return warningPatterns.Any(pattern =&gt;&#10;                System.Text.RegularExpressions.Regex.IsMatch(message, pattern, System.Text.RegularExpressions.RegexOptions.IgnoreCase));&#10;        }&#10;&#10;&#10;        private bool ValidateInputs()&#10;        {&#10;            try&#10;            {&#10;                if (string.IsNullOrWhiteSpace(SourcePathTextBox.Text))&#10;                {&#10;                    WriteToTerminal(&quot;错误: 请选择插件 .uplugin 文件&quot;, TerminalMessageType.Error);&#10;                    return false;&#10;                }&#10;&#10;                if (!File.Exists(SourcePathTextBox.Text) || !SourcePathTextBox.Text.EndsWith(&quot;.uplugin&quot;))&#10;                {&#10;                    WriteToTerminal(&quot;错误: 请选择有效的 .uplugin 文件&quot;, TerminalMessageType.Error);&#10;                    return false;&#10;                }&#10;&#10;                if (string.IsNullOrWhiteSpace(OutputPathTextBox.Text))&#10;                {&#10;                    WriteToTerminal(&quot;错误: 请选择输出路径&quot;, TerminalMessageType.Error);&#10;                    return false;&#10;                }&#10;&#10;                if (SingleBuildRadio.IsChecked == true)&#10;                {&#10;                    if (EngineVersionComboBox.SelectedItem == null)&#10;                    {&#10;                        WriteToTerminal(&quot;错误: 请选择引擎版本&quot;, TerminalMessageType.Error);&#10;                        return false;&#10;                    }&#10;&#10;                    var selectedEngine = GetSelectedEngine();&#10;                    if (selectedEngine == null || !selectedEngine.IsValid)&#10;                    {&#10;                        WriteToTerminal(&quot;错误: 选择的引擎无效或不存在&quot;, TerminalMessageType.Error);&#10;                        return false;&#10;                    }&#10;                }&#10;                else if (BatchBuildRadio.IsChecked == true)&#10;                {&#10;                    var selectedEngines = GetSelectedEnginesForBatch();&#10;                    if (!selectedEngines.Any())&#10;                    {&#10;                        WriteToTerminal(&quot;错误: 批量构建需要至少选择一个引擎版本&quot;, TerminalMessageType.Error);&#10;                        return false;&#10;                    }&#10;&#10;                    var invalidEngines = selectedEngines.Where(e =&gt; !e.IsValid).ToList();&#10;                    if (invalidEngines.Any())&#10;                    {&#10;                        WriteToTerminal($&quot;错误: 以下引擎无效: {string.Join(&quot;, &quot;, invalidEngines.Select(e =&gt; e.DisplayName))}&quot;, TerminalMessageType.Error);&#10;                        return false;&#10;                    }&#10;                }&#10;&#10;                return true;&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;验证输入时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;                return false;&#10;            }&#10;        }&#10;&#10;        private UnrealEngineInfo GetSelectedEngine()&#10;        {&#10;            try&#10;            {&#10;                var selectedItem = EngineVersionComboBox.SelectedItem as ComboBoxItem;&#10;                return selectedItem?.Tag as UnrealEngineInfo;&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;获取选择引擎时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;                return null;&#10;            }&#10;        }&#10;&#10;        private List&lt;UnrealEngineInfo&gt; GetSelectedEnginesForBatch()&#10;        {&#10;            try&#10;            {&#10;                return _engineCheckBoxes&#10;                    .Where(cb =&gt; cb.IsChecked == true)&#10;                    .Select(cb =&gt; cb.Tag as UnrealEngineInfo)&#10;                    .Where(engine =&gt; engine != null)&#10;                    .ToList();&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;获取批量引擎列表时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;                return new List&lt;UnrealEngineInfo&gt;();&#10;            }&#10;        }&#10;&#10;        private string BuildRunUATCommand(UnrealEngineInfo engine)&#10;        {&#10;            var runUATPath = Path.Combine(engine.EnginePath, &quot;Engine&quot;, &quot;Build&quot;, &quot;BatchFiles&quot;, &quot;RunUAT.bat&quot;);&#10;            var pluginPath = SourcePathTextBox.Text;&#10;            var outputPath = GetFinalOutputPath(engine);&#10;&#10;            var args = new List&lt;string&gt;&#10;            {&#10;                &quot;BuildPlugin&quot;,&#10;                $&quot;-Plugin=\&quot;{pluginPath}\&quot;&quot;,&#10;                $&quot;-Package=\&quot;{outputPath}\&quot;&quot;,&#10;                &quot;-Rocket&quot;&#10;            };&#10;&#10;            var buildConfig = GetSelectedBuildType();&#10;            if (buildConfig != &quot;Development&quot;)&#10;            {&#10;                args.Add($&quot;-{buildConfig}&quot;);&#10;            }&#10;&#10;            var platforms = GetSelectedPlatforms();&#10;            if (platforms.Length &gt; 0)&#10;            {&#10;                args.Add($&quot;-TargetPlatforms={string.Join(&quot;+&quot;, platforms)}&quot;);&#10;            }&#10;&#10;            args.Add(&quot;-VS2022&quot;);&#10;&#10;            if (CleanBuildCheckBox.IsChecked.GetValueOrDefault())&#10;            {&#10;                args.Add(&quot;-Clean&quot;);&#10;            }&#10;&#10;            return $&quot;\&quot;{runUATPath}\&quot; {string.Join(&quot; &quot;, args)}&quot;;&#10;        }&#10;&#10;        private string GetPluginBuildName()&#10;        {&#10;            try&#10;            {&#10;                if (!string.IsNullOrWhiteSpace(PluginNameTextBox.Text))&#10;                    return PluginNameTextBox.Text.Trim();&#10;&#10;                if (_currentPluginInfo != null &amp;&amp; !string.IsNullOrEmpty(_currentPluginInfo.FriendlyName))&#10;                    return _currentPluginInfo.FriendlyName;&#10;&#10;                if (!string.IsNullOrEmpty(SourcePathTextBox.Text))&#10;                    return Path.GetFileNameWithoutExtension(SourcePathTextBox.Text);&#10;&#10;                return &quot;UnnamedPlugin&quot;;&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;获取插件构建名称时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;                return &quot;UnnamedPlugin&quot;;&#10;            }&#10;        }&#10;&#10;        private string GetFinalOutputPath(UnrealEngineInfo engine)&#10;        {&#10;            var basePath = OutputPathTextBox.Text;&#10;            var pluginName = GetPluginBuildName();&#10;            var versionSuffix = _currentPluginInfo != null ? $&quot;_v{_currentPluginInfo.GetVersionString()}&quot; : &quot;&quot;;&#10;            var engineVersion = engine?.Version ?? &quot;Unknown&quot;;&#10;&#10;            return Path.Combine(basePath, $&quot;{pluginName}{versionSuffix}_{engineVersion}&quot;);&#10;        }&#10;&#10;        private string GetSelectedBuildType()&#10;        {&#10;            if (DevelopmentRadio.IsChecked.GetValueOrDefault())&#10;                return &quot;Development&quot;;&#10;            if (ShippingRadio.IsChecked.GetValueOrDefault())&#10;                return &quot;Shipping&quot;;&#10;            if (DebugRadio.IsChecked.GetValueOrDefault())&#10;                return &quot;Debug&quot;;&#10;            return &quot;Development&quot;;&#10;        }&#10;&#10;        private string[] GetSelectedPlatforms()&#10;        {&#10;            var platforms = new List&lt;string&gt;();&#10;&#10;            if (Win64CheckBox.IsChecked.GetValueOrDefault())&#10;                platforms.Add(&quot;Win64&quot;);&#10;            if (Win32CheckBox.IsChecked.GetValueOrDefault())&#10;                platforms.Add(&quot;Win32&quot;);&#10;            if (MacCheckBox.IsChecked.GetValueOrDefault())&#10;                platforms.Add(&quot;Mac&quot;);&#10;            if (LinuxCheckBox.IsChecked.GetValueOrDefault())&#10;                platforms.Add(&quot;Linux&quot;);&#10;            if (AndroidCheckBox.IsChecked.GetValueOrDefault())&#10;                platforms.Add(&quot;Android&quot;);&#10;            if (iOSCheckBox.IsChecked.GetValueOrDefault())&#10;                platforms.Add(&quot;IOS&quot;);&#10;&#10;            return platforms.ToArray();&#10;        }&#10;&#10;        private void UpdateBatchProgress(string status, int current, int total)&#10;        {&#10;            try&#10;            {&#10;                DispatcherQueue.TryEnqueue(() =&gt;&#10;                {&#10;                    if (BatchProgressStatusText != null) BatchProgressStatusText.Text = status;&#10;                    if (BatchProgressText != null) BatchProgressText.Text = $&quot;{current}/{total}&quot;;&#10;                    if (BatchProgressBar != null &amp;&amp; total &gt; 0)&#10;                    {&#10;                        BatchProgressBar.Value = (current * 100.0) / total;&#10;                    }&#10;                });&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;更新批量进度时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;            }&#10;        }&#10;&#10;        #endregion&#10;    }&#10;}" />
              <option name="updatedContent" value="using Microsoft.UI.Xaml;&#10;using Microsoft.UI.Xaml.Controls;&#10;using Microsoft.UI.Xaml.Documents;&#10;using Microsoft.UI.Xaml.Media;&#10;using System;&#10;using System.IO;&#10;using System.Threading.Tasks;&#10;using Windows.Storage;&#10;using Windows.Storage.Pickers;&#10;using System.Diagnostics;&#10;using System.Threading;&#10;using System.Text;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using System.Text.Json;&#10;using DreamUnrealManager.Services;&#10;using DreamUnrealManager.Models;&#10;using Windows.UI;&#10;using Microsoft.UI;&#10;&#10;namespace DreamUnrealManager.Views&#10;{&#10;    public sealed partial class PluginsBuildPage : Page&#10;    {&#10;        private CancellationTokenSource _buildCancellationTokenSource;&#10;        private bool _isBuildInProgress = false;&#10;        private Process _currentProcess;&#10;        private readonly EngineManagerService _engineManager;&#10;        private PluginInfo _currentPluginInfo;&#10;        private List&lt;CheckBox&gt; _engineCheckBoxes = new List&lt;CheckBox&gt;();&#10;&#10;        // 批量构建相关字段&#10;        private List&lt;UnrealEngineInfo&gt; _selectedEnginesForBatch;&#10;        private int _currentBatchIndex;&#10;        private List&lt;string&gt; _batchBuildResults;&#10;&#10;        // 错误和警告跟踪&#10;        private List&lt;BuildIssue&gt; _buildIssues = new List&lt;BuildIssue&gt;();&#10;        private int _errorCount = 0;&#10;        private int _warningCount = 0;&#10;        private UnrealEngineInfo _currentBuildingEngine;&#10;&#10;        public PluginsBuildPage()&#10;        {&#10;            this.InitializeComponent();&#10;            _engineManager = EngineManagerService.Instance;&#10;            this.Loaded += PluginsBuildPage_Loaded;&#10;        }&#10;&#10;        #region 构建问题类定义&#10;&#10;        public enum BuildIssueType&#10;        {&#10;            Error,&#10;            Warning&#10;        }&#10;&#10;        public class BuildIssue&#10;        {&#10;            public BuildIssueType Type&#10;            {&#10;                get;&#10;                set;&#10;            }&#10;&#10;            public string Message&#10;            {&#10;                get;&#10;                set;&#10;            }&#10;&#10;            public string Engine&#10;            {&#10;                get;&#10;                set;&#10;            }&#10;&#10;            public DateTime Timestamp&#10;            {&#10;                get;&#10;                set;&#10;            }&#10;&#10;            public string SourceFile&#10;            {&#10;                get;&#10;                set;&#10;            }&#10;&#10;            public int LineNumber&#10;            {&#10;                get;&#10;                set;&#10;            }&#10;        }&#10;&#10;        #endregion&#10;&#10;        private async void PluginsBuildPage_Loaded(object sender, RoutedEventArgs e)&#10;        {&#10;            try&#10;            {&#10;                await InitializePage();&#10;&#10;                // 初始化导航状态为就绪&#10;                UpdateNavigationStatus(false, 0, &quot;就绪&quot;);&#10;&#10;                // 页面加载完成后显示欢迎消息&#10;                WriteToTerminal(&quot;插件构建页面已就绪&quot;, TerminalMessageType.Success);&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                System.Diagnostics.Debug.WriteLine($&quot;页面加载失败: {ex.Message}&quot;);&#10;                UpdateNavigationStatus(false, 0, &quot;初始化失败&quot;);&#10;            }&#10;        }&#10;&#10;&#10;        private async Task InitializePage()&#10;        {&#10;            try&#10;            {&#10;                var documentsPath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);&#10;                OutputPathTextBox.Text = Path.Combine(documentsPath, &quot;PluginsBuilded&quot;);&#10;&#10;                await LoadEngineVersions();&#10;&#10;                // 确保页面完全加载后再显示初始化消息&#10;                if (this.IsLoaded)&#10;                {&#10;                    WriteToTerminal(&quot;页面初始化完成&quot;, TerminalMessageType.Success);&#10;                }&#10;&#10;                UpdateIssuesCounts();&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                System.Diagnostics.Debug.WriteLine($&quot;初始化错误: {ex.Message}&quot;);&#10;                // 初始化时的错误不显示在终端中&#10;            }&#10;        }&#10;&#10;&#10;        private async Task LoadEngineVersions()&#10;        {&#10;            try&#10;            {&#10;                await _engineManager.LoadEngines();&#10;&#10;                EngineVersionComboBox.Items.Clear();&#10;                var validEngines = _engineManager.GetValidEngines();&#10;&#10;                if (validEngines != null)&#10;                {&#10;                    foreach (var engine in validEngines)&#10;                    {&#10;                        var displayText = $&quot;{engine.DisplayName}&quot;;&#10;                        if (!string.IsNullOrEmpty(engine.FullVersion))&#10;                            displayText += $&quot; ({engine.FullVersion})&quot;;&#10;                        else if (!string.IsNullOrEmpty(engine.Version))&#10;                            displayText += $&quot; ({engine.Version})&quot;;&#10;&#10;                        var item = new ComboBoxItem&#10;                        {&#10;                            Content = displayText,&#10;                            Tag = engine&#10;                        };&#10;                        EngineVersionComboBox.Items.Add(item);&#10;                    }&#10;                }&#10;&#10;                if (EngineVersionComboBox.Items.Count &gt; 0)&#10;                    EngineVersionComboBox.SelectedIndex = 0;&#10;&#10;                LoadBatchEnginesList();&#10;&#10;                // 只有在页面完全加载后才显示加载消息&#10;                if (this.IsLoaded)&#10;                {&#10;                    WriteToTerminal($&quot;已加载 {validEngines?.Count() ?? 0} 个有效引擎版本&quot;, TerminalMessageType.Info);&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                System.Diagnostics.Debug.WriteLine($&quot;加载引擎版本失败: {ex.Message}&quot;);&#10;                // 初始化时的错误不显示在终端中&#10;            }&#10;        }&#10;&#10;&#10;        private void LoadBatchEnginesList()&#10;        {&#10;            try&#10;            {&#10;                EngineVersionsCheckList.Children.Clear();&#10;                _engineCheckBoxes.Clear();&#10;&#10;                var validEngines = _engineManager.GetValidEngines();&#10;                if (validEngines != null)&#10;                {&#10;                    foreach (var engine in validEngines)&#10;                    {&#10;                        var displayText = $&quot;{engine.DisplayName}&quot;;&#10;                        if (!string.IsNullOrEmpty(engine.FullVersion))&#10;                            displayText += $&quot; ({engine.FullVersion})&quot;;&#10;                        else if (!string.IsNullOrEmpty(engine.Version))&#10;                            displayText += $&quot; ({engine.Version})&quot;;&#10;&#10;                        var checkBox = new CheckBox&#10;                        {&#10;                            Content = displayText,&#10;                            Tag = engine,&#10;                            Margin = new Thickness(0, 2, 0, 2)&#10;                        };&#10;&#10;                        _engineCheckBoxes.Add(checkBox);&#10;                        EngineVersionsCheckList.Children.Add(checkBox);&#10;                    }&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                System.Diagnostics.Debug.WriteLine($&quot;加载批量构建列表失败: {ex.Message}&quot;);&#10;                // 初始化时的错误不显示在终端中&#10;            }&#10;        }&#10;&#10;&#10;        #region 终端输出方法&#10;&#10;        private enum TerminalMessageType&#10;        {&#10;            Info,&#10;            Success,&#10;            Warning,&#10;            Error,&#10;            Command&#10;        }&#10;&#10;        private void WriteToTerminal(string message, TerminalMessageType messageType = TerminalMessageType.Info)&#10;        {&#10;            DispatcherQueue.TryEnqueue(() =&gt;&#10;            {&#10;                try&#10;                {&#10;                    // 如果页面还没加载完成，直接返回&#10;                    if (!this.IsLoaded || TerminalOutput == null)&#10;                    {&#10;                        return;&#10;                    }&#10;&#10;                    // 过滤掉一些噪音信息&#10;                    if (ShouldFilterMessage(message))&#10;                    {&#10;                        return;&#10;                    }&#10;&#10;                    var timestamp = DateTime.Now.ToString(&quot;HH:mm:ss&quot;);&#10;                    var paragraph = new Paragraph();&#10;&#10;                    // 添加时间戳&#10;                    var timeRun = new Run { Text = $&quot;[{timestamp}] &quot; };&#10;                    timeRun.Foreground = new SolidColorBrush(Colors.Gray);&#10;                    paragraph.Inlines.Add(timeRun);&#10;&#10;                    // 根据消息类型设置颜色&#10;                    var messageRun = new Run { Text = message };&#10;                    switch (messageType)&#10;                    {&#10;                        case TerminalMessageType.Success:&#10;                            messageRun.Foreground = new SolidColorBrush(Colors.LightGreen);&#10;                            break;&#10;                        case TerminalMessageType.Warning:&#10;                            messageRun.Foreground = new SolidColorBrush(Colors.Yellow);&#10;                            break;&#10;                        case TerminalMessageType.Error:&#10;                            messageRun.Foreground = new SolidColorBrush(Colors.LightCoral);&#10;                            break;&#10;                        case TerminalMessageType.Command:&#10;                            messageRun.Foreground = new SolidColorBrush(Colors.Cyan);&#10;                            break;&#10;                        default:&#10;                            messageRun.Foreground = new SolidColorBrush(Colors.LightGray);&#10;                            break;&#10;                    }&#10;&#10;                    paragraph.Inlines.Add(messageRun);&#10;&#10;                    TerminalOutput.Blocks.Add(paragraph);&#10;&#10;                    // 检查是否包含错误或警告&#10;                    CheckForIssues(message, messageType);&#10;&#10;                    // 自动滚动到底部，确保 ScrollViewer 存在&#10;                    if (TerminalScrollViewer != null)&#10;                    {&#10;                        TerminalScrollViewer.ScrollToVerticalOffset(TerminalScrollViewer.ExtentHeight);&#10;                    }&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    System.Diagnostics.Debug.WriteLine($&quot;WriteToTerminal error: {ex.Message}&quot;);&#10;                }&#10;            });&#10;        }&#10;&#10;&#10;        // 改进 CheckForIssues 方法，添加更智能的错误检测&#10;        private void CheckForIssues(string message, TerminalMessageType messageType)&#10;        {&#10;            try&#10;            {&#10;                var lowerMessage = message.ToLower();&#10;&#10;                // 首先检查是否是已知的误报&#10;                if (IsFalseError(message))&#10;                {&#10;                    return;&#10;                }&#10;&#10;                var isError = IsRealError(message, messageType);&#10;                var isWarning = IsRealWarning(message, messageType);&#10;&#10;                if (isError || isWarning)&#10;                {&#10;                    var issue = new BuildIssue&#10;                    {&#10;                        Type = isError ? BuildIssueType.Error : BuildIssueType.Warning,&#10;                        Message = message,&#10;                        Engine = _currentBuildingEngine?.DisplayName ?? &quot;未知引擎&quot;,&#10;                        Timestamp = DateTime.Now,&#10;                        SourceFile = ExtractSourceFile(message),&#10;                        LineNumber = ExtractLineNumber(message)&#10;                    };&#10;&#10;                    _buildIssues.Add(issue);&#10;&#10;                    if (isError)&#10;                        _errorCount++;&#10;                    else&#10;                        _warningCount++;&#10;&#10;                    AddIssueToList(issue);&#10;                    UpdateIssuesCounts();&#10;                    ShowIssuesCard();&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                System.Diagnostics.Debug.WriteLine($&quot;CheckForIssues error: {ex.Message}&quot;);&#10;            }&#10;        }&#10;&#10;&#10;        private string ExtractSourceFile(string message)&#10;        {&#10;            try&#10;            {&#10;                // 尝试提取类似 &quot;C:\path\file.cpp(123)&quot; 的文件路径&#10;                var match = System.Text.RegularExpressions.Regex.Match(message, @&quot;([A-Za-z]:[^:]*\.(cpp|h|cs|hpp|c))\((\d+)\)&quot;);&#10;                if (match.Success)&#10;                {&#10;                    return System.IO.Path.GetFileName(match.Groups[1].Value);&#10;                }&#10;&#10;                // 尝试提取其他格式的文件路径&#10;                match = System.Text.RegularExpressions.Regex.Match(message, @&quot;([A-Za-z]:[^:]*\.(cpp|h|cs|hpp|c))&quot;);&#10;                if (match.Success)&#10;                {&#10;                    return System.IO.Path.GetFileName(match.Groups[1].Value);&#10;                }&#10;&#10;                return &quot;&quot;;&#10;            }&#10;            catch&#10;            {&#10;                return &quot;&quot;;&#10;            }&#10;        }&#10;&#10;        private int ExtractLineNumber(string message)&#10;        {&#10;            try&#10;            {&#10;                var match = System.Text.RegularExpressions.Regex.Match(message, @&quot;\((\d+)\)&quot;);&#10;                if (match.Success &amp;&amp; int.TryParse(match.Groups[1].Value, out int lineNumber))&#10;                {&#10;                    return lineNumber;&#10;                }&#10;&#10;                return 0;&#10;            }&#10;            catch&#10;            {&#10;                return 0;&#10;            }&#10;        }&#10;&#10;        private void AddIssueToList(BuildIssue issue)&#10;        {&#10;            DispatcherQueue.TryEnqueue(() =&gt;&#10;            {&#10;                try&#10;                {&#10;                    var border = new Border&#10;                    {&#10;                        Background = issue.Type == BuildIssueType.Error&#10;                            ? new SolidColorBrush(Color.FromArgb(30, 255, 0, 0)) // 红色半透明&#10;                            : new SolidColorBrush(Color.FromArgb(30, 255, 255, 0)), // 黄色半透明&#10;                        CornerRadius = new CornerRadius(4),&#10;                        Padding = new Thickness(10),&#10;                        Margin = new Thickness(0, 1, 0, 1)&#10;                    };&#10;&#10;                    var grid = new Grid();&#10;                    grid.ColumnDefinitions.Add(new ColumnDefinition { Width = GridLength.Auto });&#10;                    grid.ColumnDefinitions.Add(new ColumnDefinition { Width = new GridLength(1, GridUnitType.Star) });&#10;                    grid.ColumnDefinitions.Add(new ColumnDefinition { Width = GridLength.Auto });&#10;&#10;                    // 错误/警告图标&#10;                    var icon = new FontIcon&#10;                    {&#10;                        Glyph = issue.Type == BuildIssueType.Error ? &quot;\uE783&quot; : &quot;\uE7BA&quot;,&#10;                        FontSize = 14,&#10;                        Foreground = issue.Type == BuildIssueType.Error&#10;                            ? new SolidColorBrush(Colors.Red)&#10;                            : new SolidColorBrush(Colors.Orange),&#10;                        VerticalAlignment = VerticalAlignment.Top,&#10;                        Margin = new Thickness(0, 0, 8, 0)&#10;                    };&#10;                    Grid.SetColumn(icon, 0);&#10;                    grid.Children.Add(icon);&#10;&#10;                    // 消息内容&#10;                    var contentPanel = new StackPanel();&#10;&#10;                    var messageText = new TextBlock&#10;                    {&#10;                        Text = issue.Message,&#10;                        TextWrapping = TextWrapping.Wrap,&#10;                        FontSize = 13,&#10;                        Foreground = issue.Type == BuildIssueType.Error&#10;                            ? new SolidColorBrush(Colors.Red)&#10;                            : new SolidColorBrush(Colors.Orange)&#10;                    };&#10;                    contentPanel.Children.Add(messageText);&#10;&#10;                    var detailsPanel = new StackPanel&#10;                    {&#10;                        Orientation = Orientation.Horizontal,&#10;                        Spacing = 10,&#10;                        Margin = new Thickness(0, 5, 0, 0)&#10;                    };&#10;&#10;                    if (!string.IsNullOrEmpty(issue.SourceFile))&#10;                    {&#10;                        var fileText = new TextBlock&#10;                        {&#10;                            Text = issue.LineNumber &gt; 0 ? $&quot;{issue.SourceFile}:{issue.LineNumber}&quot; : issue.SourceFile,&#10;                            FontSize = 11,&#10;                            Foreground = new SolidColorBrush(Colors.Gray),&#10;                            FontFamily = new FontFamily(&quot;Consolas&quot;)&#10;                        };&#10;                        detailsPanel.Children.Add(fileText);&#10;                    }&#10;&#10;                    var engineText = new TextBlock&#10;                    {&#10;                        Text = issue.Engine,&#10;                        FontSize = 11,&#10;                        Foreground = new SolidColorBrush(Colors.Gray)&#10;                    };&#10;                    detailsPanel.Children.Add(engineText);&#10;&#10;                    contentPanel.Children.Add(detailsPanel);&#10;                    Grid.SetColumn(contentPanel, 1);&#10;                    grid.Children.Add(contentPanel);&#10;&#10;                    // 时间戳&#10;                    var timeText = new TextBlock&#10;                    {&#10;                        Text = issue.Timestamp.ToString(&quot;HH:mm:ss&quot;),&#10;                        FontSize = 11,&#10;                        Foreground = new SolidColorBrush(Colors.Gray),&#10;                        VerticalAlignment = VerticalAlignment.Top&#10;                    };&#10;                    Grid.SetColumn(timeText, 2);&#10;                    grid.Children.Add(timeText);&#10;&#10;                    border.Child = grid;&#10;&#10;                    // 如果这是第一个问题，移除占位符文本&#10;                    if (IssuesListPanel.Children.Count == 1 &amp;&amp;&#10;                        IssuesListPanel.Children[0] is TextBlock placeholder &amp;&amp;&#10;                        placeholder.Text == &quot;暂无错误或警告&quot;)&#10;                    {&#10;                        IssuesListPanel.Children.Clear();&#10;                    }&#10;&#10;                    IssuesListPanel.Children.Insert(0, border); // 最新的问题显示在顶部&#10;&#10;                    // 自动滚动到顶部显示最新问题&#10;                    IssuesScrollViewer.ScrollToVerticalOffset(0);&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    System.Diagnostics.Debug.WriteLine($&quot;AddIssueToList error: {ex.Message}&quot;);&#10;                }&#10;            });&#10;        }&#10;&#10;        private void UpdateIssuesCounts()&#10;        {&#10;            // 确保在 UI 线程上执行，并检查控件是否已初始化&#10;            DispatcherQueue.TryEnqueue(() =&gt;&#10;            {&#10;                try&#10;                {&#10;                    if (ErrorCountText != null &amp;&amp; WarningCountText != null)&#10;                    {&#10;                        ErrorCountText.Text = _errorCount.ToString();&#10;                        WarningCountText.Text = _warningCount.ToString();&#10;                    }&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    System.Diagnostics.Debug.WriteLine($&quot;UpdateIssuesCounts error: {ex.Message}&quot;);&#10;                }&#10;            });&#10;        }&#10;&#10;&#10;        private void ShowIssuesCard()&#10;        {&#10;            DispatcherQueue.TryEnqueue(() =&gt;&#10;            {&#10;                IssuesCard.Visibility = Visibility.Visible;&#10;            });&#10;        }&#10;&#10;        private void UpdateCurrentEngineInfo(UnrealEngineInfo engine, string step = &quot;准备中...&quot;)&#10;        {&#10;            DispatcherQueue.TryEnqueue(() =&gt;&#10;            {&#10;                try&#10;                {&#10;                    _currentBuildingEngine = engine;&#10;                    BuildStatusCard.Visibility = Visibility.Visible;&#10;&#10;                    CurrentEngineNameText.Text = $&quot;当前引擎: {engine?.DisplayName ?? &quot;未知&quot;}&quot;;&#10;                    CurrentEngineVersionText.Text = engine != null&#10;                        ? $&quot;版本: {engine.FullVersion ?? engine.Version ?? &quot;未知&quot;} | 路径: {Path.GetFileName(engine.EnginePath)}&quot;&#10;                        : &quot;&quot;;&#10;                    CurrentBuildStepText.Text = step;&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    System.Diagnostics.Debug.WriteLine($&quot;UpdateCurrentEngineInfo error: {ex.Message}&quot;);&#10;                }&#10;            });&#10;        }&#10;&#10;        private void UpdateBuildProgress(int percentage, string step = null)&#10;        {&#10;            DispatcherQueue.TryEnqueue(() =&gt;&#10;            {&#10;                try&#10;                {&#10;                    CurrentBuildProgressBar.Value = percentage;&#10;                    BuildProgressText.Text = $&quot;{percentage}%&quot;;&#10;&#10;                    if (!string.IsNullOrEmpty(step))&#10;                    {&#10;                        CurrentBuildStepText.Text = step;&#10;                    }&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    System.Diagnostics.Debug.WriteLine($&quot;UpdateBuildProgress error: {ex.Message}&quot;);&#10;                }&#10;            });&#10;        }&#10;&#10;        private void ClearTerminal()&#10;        {&#10;            DispatcherQueue.TryEnqueue(() =&gt;&#10;            {&#10;                try&#10;                {&#10;                    TerminalOutput.Blocks.Clear();&#10;                    var paragraph = new Paragraph();&#10;                    var run = new Run { Text = &quot;终端已清空&quot; };&#10;                    run.Foreground = new SolidColorBrush(Colors.Green);&#10;                    paragraph.Inlines.Add(run);&#10;                    TerminalOutput.Blocks.Add(paragraph);&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    System.Diagnostics.Debug.WriteLine($&quot;ClearTerminal error: {ex.Message}&quot;);&#10;                }&#10;            });&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region 事件处理&#10;&#10;        private void BuildModeRadio_Checked(object sender, RoutedEventArgs e)&#10;        {&#10;            try&#10;            {&#10;                if (SingleBuildRadio?.IsChecked == true)&#10;                {&#10;                    if (SingleBuildPanel != null) SingleBuildPanel.Visibility = Visibility.Visible;&#10;                    if (BatchBuildPanel != null) BatchBuildPanel.Visibility = Visibility.Collapsed;&#10;                    if (BatchProgressPanel != null) BatchProgressPanel.Visibility = Visibility.Collapsed;&#10;                }&#10;                else if (BatchBuildRadio?.IsChecked == true)&#10;                {&#10;                    if (SingleBuildPanel != null) SingleBuildPanel.Visibility = Visibility.Collapsed;&#10;                    if (BatchBuildPanel != null) BatchBuildPanel.Visibility = Visibility.Visible;&#10;                    if (BatchProgressPanel != null) BatchProgressPanel.Visibility = Visibility.Visible;&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;切换构建模式时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;            }&#10;        }&#10;&#10;        private void SelectAllEngines_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            foreach (var checkBox in _engineCheckBoxes)&#10;                checkBox.IsChecked = true;&#10;        }&#10;&#10;        private void DeselectAllEngines_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            foreach (var checkBox in _engineCheckBoxes)&#10;                checkBox.IsChecked = false;&#10;        }&#10;&#10;        private void SelectUE5Only_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            foreach (var checkBox in _engineCheckBoxes)&#10;            {&#10;                var engine = checkBox.Tag as UnrealEngineInfo;&#10;                checkBox.IsChecked = engine?.BuildVersionInfo?.MajorVersion == 5;&#10;            }&#10;        }&#10;&#10;        private void ClearIssues_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            _buildIssues.Clear();&#10;            _errorCount = 0;&#10;            _warningCount = 0;&#10;&#10;            IssuesListPanel.Children.Clear();&#10;            var placeholder = new TextBlock&#10;            {&#10;                Text = &quot;暂无错误或警告&quot;,&#10;                Foreground = new SolidColorBrush(Colors.Gray),&#10;                FontStyle = Windows.UI.Text.FontStyle.Italic,&#10;                HorizontalAlignment = HorizontalAlignment.Center,&#10;                Margin = new Thickness(0, 20, 0, 20)&#10;            };&#10;            IssuesListPanel.Children.Add(placeholder);&#10;&#10;            UpdateIssuesCounts();&#10;            WriteToTerminal(&quot;已清空错误和警告列表&quot;, TerminalMessageType.Info);&#10;        }&#10;&#10;        private void ToggleIssues_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            if (IssuesScrollViewer.Visibility == Visibility.Visible)&#10;            {&#10;                IssuesScrollViewer.Visibility = Visibility.Collapsed;&#10;                CollapseIssuesButton.Content = &quot;展开&quot;;&#10;            }&#10;            else&#10;            {&#10;                IssuesScrollViewer.Visibility = Visibility.Visible;&#10;                CollapseIssuesButton.Content = &quot;收起&quot;;&#10;            }&#10;        }&#10;&#10;        private void ClearTerminal_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            ClearTerminal();&#10;        }&#10;&#10;        private void ScrollToBottom_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            TerminalScrollViewer.ScrollToVerticalOffset(TerminalScrollViewer.ExtentHeight);&#10;        }&#10;&#10;        // ... 其他事件处理方法保持不变 ...&#10;&#10;        #endregion&#10;&#10;        #region 构建方法&#10;&#10;        private async void StartBuild_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            if (_isBuildInProgress)&#10;                return;&#10;&#10;            if (!ValidateInputs())&#10;                return;&#10;&#10;            // 清空之前的问题列表&#10;            ClearIssues_Click(null, null);&#10;&#10;            _isBuildInProgress = true;&#10;            _buildCancellationTokenSource = new CancellationTokenSource();&#10;&#10;            StartBuildButton.IsEnabled = false;&#10;            StopBuildButton.IsEnabled = true;&#10;&#10;            // 更新导航栏状态：开始构建&#10;            UpdateNavigationStatus(true, 1, &quot;插件构建中...&quot;);&#10;&#10;            WriteToTerminal(&quot;=== 开始插件构建 ===&quot;, TerminalMessageType.Success);&#10;&#10;            // 显示插件详细信息&#10;            if (_currentPluginInfo != null)&#10;            {&#10;                WriteToTerminal($&quot;插件名称: {_currentPluginInfo.GetDisplayName()}&quot;, TerminalMessageType.Info);&#10;                WriteToTerminal($&quot;插件版本: {_currentPluginInfo.GetVersionString()}&quot;, TerminalMessageType.Info);&#10;                WriteToTerminal($&quot;作者: {_currentPluginInfo.CreatedBy ?? &quot;未知&quot;}&quot;, TerminalMessageType.Info);&#10;                WriteToTerminal($&quot;模块数量: {_currentPluginInfo.GetModuleCount()}&quot;, TerminalMessageType.Info);&#10;            }&#10;&#10;            try&#10;            {&#10;                if (SingleBuildRadio.IsChecked == true)&#10;                {&#10;                    await PerformSingleBuildAsync(_buildCancellationTokenSource.Token);&#10;                }&#10;                else&#10;                {&#10;                    // 批量构建&#10;                    var selectedEngines = GetSelectedEnginesForBatch();&#10;                    UpdateNavigationStatus(true, selectedEngines.Count, $&quot;批量构建中 (共{selectedEngines.Count}个引擎)&quot;);&#10;                    await PerformBatchBuildAsync(_buildCancellationTokenSource.Token);&#10;                }&#10;&#10;                // 构建成功完成&#10;                UpdateNavigationStatus(false, 0, &quot;构建完成&quot;);&#10;                WriteToTerminal(&quot;=== 构建成功完成 ===&quot;, TerminalMessageType.Success);&#10;            }&#10;            catch (OperationCanceledException)&#10;            {&#10;                WriteToTerminal(&quot;构建已被用户取消&quot;, TerminalMessageType.Warning);&#10;                UpdateNavigationStatus(false, 0, &quot;构建已取消&quot;);&#10;                UpdateCurrentEngineInfo(null, &quot;已取消&quot;);&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;构建过程中发生错误: {ex.Message}&quot;, TerminalMessageType.Error);&#10;                UpdateNavigationStatus(false, 0, $&quot;构建失败: {ex.Message}&quot;);&#10;                UpdateCurrentEngineInfo(null, &quot;构建失败&quot;);&#10;            }&#10;            finally&#10;            {&#10;                _isBuildInProgress = false;&#10;                StartBuildButton.IsEnabled = true;&#10;                StopBuildButton.IsEnabled = false;&#10;                _buildCancellationTokenSource?.Dispose();&#10;                _buildCancellationTokenSource = null;&#10;                BuildStatusCard.Visibility = Visibility.Collapsed;&#10;&#10;                // 延迟3秒后清除状态&#10;                await Task.Delay(3000);&#10;                if (!_isBuildInProgress) // 确保没有新的构建开始&#10;                {&#10;                    UpdateNavigationStatus(false, 0, &quot;就绪&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;&#10;        private async Task PerformSingleBuildAsync(CancellationToken cancellationToken)&#10;        {&#10;            var engine = GetSelectedEngine();&#10;            UpdateCurrentEngineInfo(engine, &quot;开始构建&quot;);&#10;            await ExecuteRunUATCommand(engine, cancellationToken);&#10;        }&#10;&#10;        private async Task PerformBatchBuildAsync(CancellationToken cancellationToken)&#10;        {&#10;            _selectedEnginesForBatch = GetSelectedEnginesForBatch();&#10;            _batchBuildResults = new List&lt;string&gt;();&#10;&#10;            WriteToTerminal($&quot;开始批量构建，共 {_selectedEnginesForBatch.Count} 个引擎版本&quot;, TerminalMessageType.Info);&#10;&#10;            // 更新为批量构建状态&#10;            UpdateNavigationStatus(true, _selectedEnginesForBatch.Count, $&quot;批量构建 (0/{_selectedEnginesForBatch.Count})&quot;);&#10;&#10;            for (int i = 0; i &lt; _selectedEnginesForBatch.Count; i++)&#10;            {&#10;                var engine = _selectedEnginesForBatch[i];&#10;&#10;                // 更新批量构建进度&#10;                UpdateNavigationStatus(true, _selectedEnginesForBatch.Count, $&quot;批量构建 ({i + 1}/{_selectedEnginesForBatch.Count})&quot;);&#10;&#10;                UpdateBatchProgress($&quot;构建 {engine.DisplayName} ({i + 1}/{_selectedEnginesForBatch.Count})&quot;,&#10;                    i, _selectedEnginesForBatch.Count);&#10;&#10;                UpdateCurrentEngineInfo(engine, $&quot;批量构建 {i + 1}/{_selectedEnginesForBatch.Count}&quot;);&#10;&#10;                WriteToTerminal($&quot;=== 开始构建 {engine.DisplayName} ({engine.FullVersion ?? engine.Version}) ===&quot;, TerminalMessageType.Info);&#10;&#10;                try&#10;                {&#10;                    await ExecuteRunUATCommand(engine, cancellationToken);&#10;&#10;                    var result = $&quot;✓ {engine.DisplayName}: 构建成功&quot;;&#10;                    _batchBuildResults.Add(result);&#10;                    WriteToTerminal(result, TerminalMessageType.Success);&#10;                }&#10;                catch (OperationCanceledException)&#10;                {&#10;                    throw;&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    var result = $&quot;✗ {engine.DisplayName}: 构建失败 - {ex.Message}&quot;;&#10;                    _batchBuildResults.Add(result);&#10;                    WriteToTerminal(result, TerminalMessageType.Error);&#10;&#10;                    if (StopOnErrorCheckBox.IsChecked.GetValueOrDefault())&#10;                    {&#10;                        WriteToTerminal(&quot;根据设置，遇到错误时停止批量构建&quot;, TerminalMessageType.Warning);&#10;                        UpdateNavigationStatus(true, 1, &quot;批量构建因错误停止&quot;);&#10;                        break;&#10;                    }&#10;                }&#10;            }&#10;&#10;            // 显示批量构建结果摘要&#10;            WriteToTerminal(&quot;=== 批量构建完成 ===&quot;, TerminalMessageType.Info);&#10;            foreach (var result in _batchBuildResults)&#10;            {&#10;                WriteToTerminal(result, result.StartsWith(&quot;✓&quot;) ? TerminalMessageType.Success : TerminalMessageType.Error);&#10;            }&#10;&#10;            var successCount = _batchBuildResults.Count(r =&gt; r.StartsWith(&quot;✓&quot;));&#10;            var failCount = _batchBuildResults.Count(r =&gt; r.StartsWith(&quot;✗&quot;));&#10;&#10;            UpdateBatchProgress($&quot;批量构建完成: {successCount} 成功, {failCount} 失败&quot;,&#10;                _selectedEnginesForBatch.Count, _selectedEnginesForBatch.Count);&#10;&#10;            UpdateCurrentEngineInfo(null, &quot;批量构建完成&quot;);&#10;&#10;            // 更新最终状态&#10;            if (failCount &gt; 0)&#10;            {&#10;                UpdateNavigationStatus(false, 0, $&quot;批量构建完成: {successCount}成功 {failCount}失败&quot;);&#10;            }&#10;            else&#10;            {&#10;                UpdateNavigationStatus(false, 0, $&quot;批量构建完成: 全部{successCount}个成功&quot;);&#10;            }&#10;        }&#10;&#10;&#10;        private async Task ExecuteRunUATCommand(UnrealEngineInfo engine, CancellationToken cancellationToken)&#10;        {&#10;            UpdateCurrentEngineInfo(engine, &quot;验证引擎配置&quot;);&#10;            // 更新具体的引擎构建状态&#10;            UpdateNavigationStatus(true, 1, $&quot;构建 {engine.DisplayName}&quot;);&#10;&#10;            WriteToTerminal($&quot;验证引擎配置: {engine.DisplayName}&quot;, TerminalMessageType.Info);&#10;&#10;            var runUATPath = Path.Combine(engine.EnginePath, &quot;Engine&quot;, &quot;Build&quot;, &quot;BatchFiles&quot;, &quot;RunUAT.bat&quot;);&#10;            if (!File.Exists(runUATPath))&#10;            {&#10;                throw new Exception($&quot;RunUAT.bat 不存在: {runUATPath}&quot;);&#10;            }&#10;&#10;            WriteToTerminal($&quot;RunUAT.bat 路径: {runUATPath}&quot;, TerminalMessageType.Info);&#10;&#10;            var outputPath = GetFinalOutputPath(engine);&#10;            Directory.CreateDirectory(outputPath);&#10;&#10;            var command = BuildRunUATCommand(engine);&#10;            WriteToTerminal($&quot;执行命令: {command}&quot;, TerminalMessageType.Command);&#10;&#10;            UpdateCurrentEngineInfo(engine, &quot;启动 UAT 构建进程&quot;);&#10;            UpdateBuildProgress(10, &quot;启动构建进程&quot;);&#10;            // 更新导航状态为正在编译&#10;            UpdateNavigationStatus(true, 1, $&quot;正在编译 {engine.DisplayName}&quot;);&#10;&#10;            var processInfo = new ProcessStartInfo&#10;            {&#10;                FileName = &quot;cmd.exe&quot;,&#10;                Arguments = $&quot;/c \&quot;{command}\&quot;&quot;,&#10;                UseShellExecute = false,&#10;                RedirectStandardOutput = true,&#10;                RedirectStandardError = true,&#10;                CreateNoWindow = true,&#10;                StandardOutputEncoding = Encoding.UTF8,&#10;                StandardErrorEncoding = Encoding.UTF8,&#10;                WorkingDirectory = Path.GetDirectoryName(runUATPath)&#10;            };&#10;&#10;            _currentProcess = new Process { StartInfo = processInfo };&#10;&#10;            _currentProcess.OutputDataReceived += (sender, args) =&gt;&#10;            {&#10;                if (!string.IsNullOrEmpty(args.Data))&#10;                {&#10;                    WriteToTerminal(args.Data, TerminalMessageType.Info);&#10;                    UpdateBuildProgressFromOutput(args.Data);&#10;                    UpdateNavigationStatusFromOutput(args.Data, engine);&#10;                }&#10;            };&#10;&#10;            _currentProcess.ErrorDataReceived += (sender, args) =&gt;&#10;            {&#10;                if (!string.IsNullOrEmpty(args.Data))&#10;                {&#10;                    WriteToTerminal(args.Data, TerminalMessageType.Error);&#10;                    // 检查是否是严重错误&#10;                    if (IsRealError(args.Data, TerminalMessageType.Error))&#10;                    {&#10;                        UpdateNavigationStatus(true, 1, $&quot;构建错误: {engine.DisplayName}&quot;);&#10;                    }&#10;                }&#10;            };&#10;&#10;            try&#10;            {&#10;                _currentProcess.Start();&#10;                _currentProcess.BeginOutputReadLine();&#10;                _currentProcess.BeginErrorReadLine();&#10;&#10;                while (!_currentProcess.HasExited)&#10;                {&#10;                    cancellationToken.ThrowIfCancellationRequested();&#10;                    await Task.Delay(500, cancellationToken);&#10;                }&#10;&#10;                _currentProcess.WaitForExit();&#10;&#10;                if (_currentProcess.ExitCode == 0)&#10;                {&#10;                    UpdateBuildProgress(100, &quot;构建完成&quot;);&#10;                    UpdateNavigationStatus(true, 1, $&quot;构建完成: {engine.DisplayName}&quot;);&#10;                    WriteToTerminal($&quot;=== {engine.DisplayName} 构建成功完成 ===&quot;, TerminalMessageType.Success);&#10;                    WriteToTerminal($&quot;输出路径: {outputPath}&quot;, TerminalMessageType.Success);&#10;                }&#10;                else&#10;                {&#10;                    UpdateBuildProgress(0, &quot;构建失败&quot;);&#10;                    UpdateNavigationStatus(true, 1, $&quot;构建失败: {engine.DisplayName}&quot;);&#10;                    throw new Exception($&quot;构建失败，退出代码: {_currentProcess.ExitCode}&quot;);&#10;                }&#10;            }&#10;            catch (OperationCanceledException)&#10;            {&#10;                if (_currentProcess != null &amp;&amp; !_currentProcess.HasExited)&#10;                {&#10;                    _currentProcess.Kill();&#10;                    WriteToTerminal(&quot;构建进程已被终止&quot;, TerminalMessageType.Warning);&#10;                    UpdateNavigationStatus(false, 0, &quot;构建已取消&quot;);&#10;                }&#10;&#10;                throw;&#10;            }&#10;            finally&#10;            {&#10;                _currentProcess?.Dispose();&#10;                _currentProcess = null;&#10;            }&#10;        }&#10;&#10;&#10;        private void UpdateBuildProgressFromOutput(string output)&#10;        {&#10;            try&#10;            {&#10;                var lowerOutput = output.ToLower();&#10;&#10;                if (lowerOutput.Contains(&quot;parsing&quot;) || lowerOutput.Contains(&quot;loading&quot;))&#10;                {&#10;                    UpdateBuildProgress(20, &quot;解析项目文件&quot;);&#10;                }&#10;                else if (lowerOutput.Contains(&quot;compiling&quot;) || lowerOutput.Contains(&quot;building&quot;))&#10;                {&#10;                    UpdateBuildProgress(50, &quot;正在编译插件&quot;);&#10;                }&#10;                else if (lowerOutput.Contains(&quot;linking&quot;))&#10;                {&#10;                    UpdateBuildProgress(70, &quot;正在链接&quot;);&#10;                }&#10;                else if (lowerOutput.Contains(&quot;packaging&quot;) || lowerOutput.Contains(&quot;copying&quot;))&#10;                {&#10;                    UpdateBuildProgress(80, &quot;正在打包插件&quot;);&#10;                }&#10;                else if (lowerOutput.Contains(&quot;success&quot;) || lowerOutput.Contains(&quot;completed&quot;))&#10;                {&#10;                    UpdateBuildProgress(90, &quot;构建接近完成&quot;);&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                System.Diagnostics.Debug.WriteLine($&quot;UpdateBuildProgressFromOutput error: {ex.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        // ... 其他方法保持不变，但需要添加一些事件处理 ...&#10;&#10;        private async void BrowseSourcePath_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            try&#10;            {&#10;                var filePicker = new FileOpenPicker();&#10;                filePicker.SuggestedStartLocation = PickerLocationId.Desktop;&#10;                filePicker.FileTypeFilter.Add(&quot;.uplugin&quot;);&#10;&#10;                var window = App.MainWindow;&#10;                if (window != null)&#10;                {&#10;                    var hwnd = WinRT.Interop.WindowNative.GetWindowHandle(window);&#10;                    WinRT.Interop.InitializeWithWindow.Initialize(filePicker, hwnd);&#10;                }&#10;&#10;                var file = await filePicker.PickSingleFileAsync();&#10;                if (file != null)&#10;                {&#10;                    SourcePathTextBox.Text = file.Path;&#10;                    WriteToTerminal($&quot;已选择插件文件: {file.Path}&quot;, TerminalMessageType.Success);&#10;                    await LoadPluginInfo(file.Path);&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;选择插件文件时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;            }&#10;        }&#10;&#10;        private async void BrowseOutputPath_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            try&#10;            {&#10;                var folderPicker = new FolderPicker();&#10;                folderPicker.SuggestedStartLocation = PickerLocationId.Desktop;&#10;                folderPicker.FileTypeFilter.Add(&quot;*&quot;);&#10;&#10;                var window = App.MainWindow;&#10;                if (window != null)&#10;                {&#10;                    var hwnd = WinRT.Interop.WindowNative.GetWindowHandle(window);&#10;                    WinRT.Interop.InitializeWithWindow.Initialize(folderPicker, hwnd);&#10;                }&#10;&#10;                var folder = await folderPicker.PickSingleFolderAsync();&#10;                if (folder != null)&#10;                {&#10;                    OutputPathTextBox.Text = folder.Path;&#10;                    WriteToTerminal($&quot;已选择输出路径: {folder.Path}&quot;, TerminalMessageType.Success);&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;选择输出路径时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;            }&#10;        }&#10;&#10;        private void PreviewCommand_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            try&#10;            {&#10;                if (!ValidateInputs())&#10;                    return;&#10;&#10;                var commands = new List&lt;string&gt;();&#10;&#10;                if (SingleBuildRadio.IsChecked == true)&#10;                {&#10;                    var engine = GetSelectedEngine();&#10;                    var command = BuildRunUATCommand(engine);&#10;                    commands.Add(command);&#10;                }&#10;                else&#10;                {&#10;                    var engines = GetSelectedEnginesForBatch();&#10;                    foreach (var engine in engines)&#10;                    {&#10;                        var command = BuildRunUATCommand(engine);&#10;                        commands.Add($&quot;# {engine.DisplayName}:&quot;);&#10;                        commands.Add(command);&#10;                        commands.Add(&quot;&quot;);&#10;                    }&#10;                }&#10;&#10;                CommandPreviewText.Text = string.Join(&quot;\n\n&quot;, commands);&#10;                CommandPreviewPanel.Visibility = Visibility.Visible;&#10;                WriteToTerminal(&quot;已生成构建命令预览&quot;, TerminalMessageType.Info);&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;生成命令预览时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;            }&#10;        }&#10;&#10;        private void OpenOutput_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            try&#10;            {&#10;                var outputPath = OutputPathTextBox.Text;&#10;                if (Directory.Exists(outputPath))&#10;                {&#10;                    Process.Start(&quot;explorer.exe&quot;, outputPath);&#10;                    WriteToTerminal($&quot;已打开输出目录: {outputPath}&quot;, TerminalMessageType.Success);&#10;                }&#10;                else&#10;                {&#10;                    WriteToTerminal($&quot;输出目录不存在: {outputPath}&quot;, TerminalMessageType.Warning);&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;打开输出目录时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;            }&#10;        }&#10;&#10;        private void StopBuild_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            try&#10;            {&#10;                if (_buildCancellationTokenSource != null &amp;&amp; !_buildCancellationTokenSource.Token.IsCancellationRequested)&#10;                {&#10;                    _buildCancellationTokenSource.Cancel();&#10;&#10;                    if (_currentProcess != null &amp;&amp; !_currentProcess.HasExited)&#10;                    {&#10;                        _currentProcess.Kill();&#10;                        WriteToTerminal(&quot;正在强制终止构建进程...&quot;, TerminalMessageType.Warning);&#10;                    }&#10;&#10;                    WriteToTerminal(&quot;正在取消构建...&quot;, TerminalMessageType.Warning);&#10;                    UpdateCurrentEngineInfo(_currentBuildingEngine, &quot;正在取消...&quot;);&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;取消构建时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;            }&#10;        }&#10;&#10;        // 添加终端大小调整的事件处理&#10;        private void TerminalSizeComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)&#10;        {&#10;            try&#10;            {&#10;                if (sender is ComboBox comboBox &amp;&amp; comboBox.SelectedItem is ComboBoxItem selectedItem)&#10;                {&#10;                    if (int.TryParse(selectedItem.Tag?.ToString(), out int height))&#10;                    {&#10;                        // 确保 TerminalScrollViewer 已经初始化&#10;                        if (TerminalScrollViewer != null)&#10;                        {&#10;                            TerminalScrollViewer.Height = height;&#10;&#10;                            // 只有在页面完全加载后才显示调整消息&#10;                            if (this.IsLoaded)&#10;                            {&#10;                                WriteToTerminal($&quot;终端高度已调整为 {height}px&quot;, TerminalMessageType.Info);&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                System.Diagnostics.Debug.WriteLine($&quot;调整终端大小时出错: {ex.Message}&quot;);&#10;                // 不在初始化时显示错误，避免循环调用&#10;            }&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region 导航状态管理&#10;&#10;        /// &lt;summary&gt;&#10;        /// 更新导航栏中的 InfoBadge 状态&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;isActive&quot;&gt;是否有活动任务&lt;/param&gt;&#10;        /// &lt;param name=&quot;taskCount&quot;&gt;任务数量&lt;/param&gt;&#10;        /// &lt;param name=&quot;statusText&quot;&gt;状态文本&lt;/param&gt;&#10;        private void UpdateNavigationStatus(bool isActive, int taskCount, string statusText)&#10;        {&#10;            try&#10;            {&#10;                // 使用全局状态服务更新&#10;                if (isActive)&#10;                {&#10;                    Services.PluginsBuildStatusService.Instance.UpdateStatus(isActive, taskCount, statusText);&#10;                }&#10;                else&#10;                {&#10;                    Services.PluginsBuildStatusService.Instance.UpdateStatus(false, 0, statusText);&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                System.Diagnostics.Debug.WriteLine($&quot;UpdateNavigationStatus error: {ex.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// 根据构建输出更新导航状态&#10;        /// &lt;/summary&gt;&#10;        private void UpdateNavigationStatusFromOutput(string output, UnrealEngineInfo engine)&#10;        {&#10;            try&#10;            {&#10;                var lowerOutput = output.ToLower();&#10;&#10;                if (lowerOutput.Contains(&quot;parsing&quot;) || lowerOutput.Contains(&quot;loading&quot;))&#10;                {&#10;                    UpdateNavigationStatus(true, 1, $&quot;解析项目: {engine.DisplayName}&quot;);&#10;                }&#10;                else if (lowerMessage.Contains(&quot;compiling&quot;) || lowerMessage.Contains(&quot;building&quot;))&#10;                {&#10;                    UpdateNavigationStatus(true, 1, $&quot;正在编译: {engine.DisplayName}&quot;);&#10;                }&#10;                else if (lowerOutput.Contains(&quot;linking&quot;))&#10;                {&#10;                    UpdateNavigationStatus(true, 1, $&quot;正在链接: {engine.DisplayName}&quot;);&#10;                }&#10;                else if (lowerOutput.Contains(&quot;packaging&quot;) || lowerOutput.Contains(&quot;copying&quot;))&#10;                {&#10;                    UpdateNavigationStatus(true, 1, $&quot;正在打包: {engine.DisplayName}&quot;);&#10;                }&#10;                else if (lowerOutput.Contains(&quot;success&quot;) || lowerOutput.Contains(&quot;completed&quot;))&#10;                {&#10;                    UpdateNavigationStatus(true, 1, $&quot;即将完成: {engine.DisplayName}&quot;);&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                System.Diagnostics.Debug.WriteLine($&quot;UpdateNavigationStatusFromOutput error: {ex.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        #endregion&#10;&#10;&#10;        #region 辅助方法&#10;&#10;        // 包括: LoadPluginInfo, DisplayPluginInfo, ValidateInputs, GetSelectedEngine, &#10;        // GetSelectedEnginesForBatch, BuildRunUATCommand, GetFinalOutputPath, &#10;        // GetSelectedBuildType, GetSelectedPlatforms, UpdateBatchProgress 等&#10;&#10;        private async Task LoadPluginInfo(string pluginPath)&#10;        {&#10;            try&#10;            {&#10;                if (!File.Exists(pluginPath) || !pluginPath.EndsWith(&quot;.uplugin&quot;))&#10;                {&#10;                    WriteToTerminal(&quot;错误: 请选择有效的 .uplugin 文件&quot;, TerminalMessageType.Error);&#10;                    return;&#10;                }&#10;&#10;                var content = await File.ReadAllTextAsync(pluginPath, Encoding.UTF8);&#10;                _currentPluginInfo = JsonSerializer.Deserialize&lt;PluginInfo&gt;(content, new JsonSerializerOptions&#10;                {&#10;                    PropertyNameCaseInsensitive = true&#10;                });&#10;&#10;                if (_currentPluginInfo != null)&#10;                {&#10;                    DisplayPluginInfo(_currentPluginInfo);&#10;                    WriteToTerminal($&quot;成功解析插件信息: {_currentPluginInfo.GetDisplayName()} v{_currentPluginInfo.GetVersionString()}&quot;, TerminalMessageType.Success);&#10;                }&#10;                else&#10;                {&#10;                    WriteToTerminal(&quot;警告: 无法解析插件文件内容&quot;, TerminalMessageType.Warning);&#10;                }&#10;            }&#10;            catch (JsonException ex)&#10;            {&#10;                WriteToTerminal($&quot;解析插件文件失败: {ex.Message}&quot;, TerminalMessageType.Error);&#10;                _currentPluginInfo = null;&#10;                HidePluginInfo();&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;读取插件文件时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;                _currentPluginInfo = null;&#10;                HidePluginInfo();&#10;            }&#10;        }&#10;&#10;        private bool ShouldFilterMessage(string message)&#10;        {&#10;            // 过滤一些噪音消息&#10;            var noisePatterns = new[]&#10;            {&#10;                @&quot;^LogTemp:\s*Display:&quot;,&#10;                @&quot;^LogInit:\s*Display:&quot;,&#10;                @&quot;^LogCore:\s*Display:&quot;,&#10;                @&quot;^LogEngine:\s*Display:&quot;,&#10;                @&quot;^LogOutputDevice:&quot;,&#10;                @&quot;^LogModuleManager:&quot;,&#10;                @&quot;^LogWindows:&quot;,&#10;                @&quot;Reading BuildConfiguration&quot;,&#10;                @&quot;Executing actions \(\d+ in parallel\)&quot;,&#10;                @&quot;^\s*$&quot;, // 空行&#10;                @&quot;^Running Internal UnrealHeaderTool.*-WarningsAsErrors -installed$&quot;,&#10;                @&quot;Determining max actions to execute&quot;,&#10;                @&quot;Building UnrealHeaderTool&quot;,&#10;                @&quot;Parsing headers for&quot;,&#10;                @&quot;Generated code for target&quot;,&#10;                @&quot;Total execution time:&quot;&#10;            };&#10;&#10;            return noisePatterns.Any(pattern =&gt;&#10;                System.Text.RegularExpressions.Regex.IsMatch(message, pattern, System.Text.RegularExpressions.RegexOptions.IgnoreCase));&#10;        }&#10;&#10;&#10;        private void DisplayPluginInfo(PluginInfo pluginInfo)&#10;        {&#10;            try&#10;            {&#10;                PluginInfoPanel.Visibility = Visibility.Visible;&#10;&#10;                PluginFriendlyNameText.Text = pluginInfo.GetDisplayName();&#10;                PluginVersionText.Text = pluginInfo.GetVersionString();&#10;                PluginDescriptionText.Text = string.IsNullOrEmpty(pluginInfo.Description) ? &quot;无描述&quot; : pluginInfo.Description;&#10;                PluginCreatedByText.Text = string.IsNullOrEmpty(pluginInfo.CreatedBy) ? &quot;未知&quot; : pluginInfo.CreatedBy;&#10;&#10;                var moduleInfos = new List&lt;string&gt;();&#10;                if (pluginInfo.Modules?.Count &gt; 0)&#10;                {&#10;                    var runtimeModules = pluginInfo.Modules.Count(m =&gt; m.Type == &quot;Runtime&quot; || m.Type == &quot;RuntimeAndProgram&quot;);&#10;                    var editorModules = pluginInfo.Modules.Count(m =&gt; m.Type == &quot;Editor&quot; || m.Type == &quot;UncookedOnly&quot;);&#10;                    var otherModules = pluginInfo.Modules.Count - runtimeModules - editorModules;&#10;&#10;                    if (runtimeModules &gt; 0) moduleInfos.Add($&quot;{runtimeModules} 运行时&quot;);&#10;                    if (editorModules &gt; 0) moduleInfos.Add($&quot;{editorModules} 编辑器&quot;);&#10;                    if (otherModules &gt; 0) moduleInfos.Add($&quot;{otherModules} 其他&quot;);&#10;&#10;                    moduleInfos.Add($&quot;(共 {pluginInfo.Modules.Count} 个模块)&quot;);&#10;                }&#10;                else&#10;                {&#10;                    moduleInfos.Add(&quot;无模块信息&quot;);&#10;                }&#10;&#10;                PluginModulesText.Text = string.Join(&quot;, &quot;, moduleInfos);&#10;&#10;                if (string.IsNullOrWhiteSpace(PluginNameTextBox.Text))&#10;                {&#10;                    PluginNameTextBox.PlaceholderText = $&quot;留空将使用: {pluginInfo.GetDisplayName()}&quot;;&#10;                }&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;显示插件信息时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;            }&#10;        }&#10;&#10;        private void HidePluginInfo()&#10;        {&#10;            try&#10;            {&#10;                PluginInfoPanel.Visibility = Visibility.Collapsed;&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                System.Diagnostics.Debug.WriteLine($&quot;HidePluginInfo error: {ex.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        // 在类的字段部分添加这些变量&#10;        // 错误过滤关键字列表&#10;        private readonly HashSet&lt;string&gt; _falseErrorKeywords = new HashSet&lt;string&gt;(StringComparer.OrdinalIgnoreCase)&#10;        {&#10;            &quot;Running Internal UnrealHeaderTool&quot;,&#10;            &quot;LogTemp:&quot;,&#10;            &quot;LogInit:&quot;,&#10;            &quot;LogCore:&quot;,&#10;            &quot;LogEngine:&quot;,&#10;            &quot;UATHelper:&quot;,&#10;            &quot;AutomationTool:&quot;,&#10;            &quot;BuildCommand.Execute:&quot;,&#10;            &quot;Program.Main:&quot;,&#10;            &quot;UnrealBuildTool.Main:&quot;,&#10;            &quot;LogModuleManager:&quot;,&#10;            &quot;LogOutputDevice:&quot;,&#10;            &quot;LogWindows:&quot;,&#10;            &quot;LogD3D11RHI:&quot;,&#10;            &quot;Reading BuildConfiguration&quot;,&#10;            &quot;Determining max actions&quot;,&#10;            &quot;Executing actions&quot;,&#10;            &quot;Building UnrealHeaderTool&quot;,&#10;            &quot;Parsing headers&quot;,&#10;            &quot;Generated code&quot;,&#10;            &quot;Total execution time&quot;&#10;        };&#10;&#10;        private bool IsFalseError(string message)&#10;        {&#10;            // 检查是否包含误报关键字&#10;            if (_falseErrorKeywords.Any(keyword =&gt; message.Contains(keyword, StringComparison.OrdinalIgnoreCase)))&#10;            {&#10;                return true;&#10;            }&#10;&#10;            // 检查特定模式&#10;            var patterns = new[]&#10;            {&#10;                @&quot;Running Internal UnrealHeaderTool.*\.uproject&quot;,&#10;                @&quot;LogTemp:\s*Display:&quot;,&#10;                @&quot;LogInit:\s*Display:&quot;,&#10;                @&quot;LogCore:\s*Display:&quot;,&#10;                @&quot;LogEngine:\s*Display:&quot;,&#10;                @&quot;UATHelper:\s*.*&quot;,&#10;                @&quot;AutomationTool:\s*.*&quot;,&#10;                @&quot;BuildCommand\.Execute:\s*.*&quot;,&#10;                @&quot;Program\.Main:\s*.*&quot;,&#10;                @&quot;Reading BuildConfiguration.*&quot;,&#10;                @&quot;Determining max actions.*&quot;,&#10;                @&quot;Executing actions.*&quot;,&#10;                @&quot;Building.*\.exe.*&quot;,&#10;                @&quot;Parsing headers.*&quot;,&#10;                @&quot;Generated code.*&quot;,&#10;                @&quot;Total execution time.*&quot;,&#10;                @&quot;LogModuleManager:\s*.*&quot;,&#10;                @&quot;LogOutputDevice:\s*.*&quot;&#10;            };&#10;&#10;            foreach (var pattern in patterns)&#10;            {&#10;                if (System.Text.RegularExpressions.Regex.IsMatch(message, pattern, System.Text.RegularExpressions.RegexOptions.IgnoreCase))&#10;                {&#10;                    return true;&#10;                }&#10;            }&#10;&#10;            return false;&#10;        }&#10;&#10;        private bool IsRealError(string message, TerminalMessageType messageType)&#10;        {&#10;            if (messageType == TerminalMessageType.Error)&#10;                return true;&#10;&#10;            var lowerMessage = message.ToLower();&#10;&#10;            // 真正的错误模式&#10;            var errorPatterns = new[]&#10;            {&#10;                @&quot;\berror\s*C\d+:&quot;,&#10;                @&quot;\berror\s*LNK\d+:&quot;,&#10;                @&quot;\berror\s*MSB\d+:&quot;,&#10;                @&quot;fatal\s*error:&quot;,&#10;                @&quot;compilation\s*failed&quot;,&#10;                @&quot;build\s*failed&quot;,&#10;                @&quot;failed\s*to\s*compile&quot;,&#10;                @&quot;unresolved\s*external\s*symbol&quot;,&#10;                @&quot;undefined\s*reference&quot;,&#10;                @&quot;syntax\s*error&quot;,&#10;                @&quot;parse\s*error&quot;,&#10;                @&quot;.*\.cpp\(\d+\):\s*error&quot;,&#10;                @&quot;.*\.h\(\d+\):\s*error&quot;,&#10;                @&quot;.*\.cs\(\d+\):\s*error&quot;,&#10;                @&quot;exception\s*thrown&quot;,&#10;                @&quot;access\s*violation&quot;,&#10;                @&quot;segmentation\s*fault&quot;&#10;            };&#10;&#10;            return errorPatterns.Any(pattern =&gt;&#10;                System.Text.RegularExpressions.Regex.IsMatch(message, pattern, System.Text.RegularExpressions.RegexOptions.IgnoreCase));&#10;        }&#10;&#10;        private bool IsRealWarning(string message, TerminalMessageType messageType)&#10;        {&#10;            if (messageType == TerminalMessageType.Warning)&#10;                return true;&#10;&#10;            var lowerMessage = message.ToLower();&#10;&#10;            // 真正的警告模式&#10;            var warningPatterns = new[]&#10;            {&#10;                @&quot;\bwarning\s*C\d+:&quot;,&#10;                @&quot;\bwarning\s*LNK\d+:&quot;,&#10;                @&quot;\bwarning\s*MSB\d+:&quot;,&#10;                @&quot;.*\.cpp\(\d+\):\s*warning&quot;,&#10;                @&quot;.*\.h\(\d+\):\s*warning&quot;,&#10;                @&quot;.*\.cs\(\d+\):\s*warning&quot;,&#10;                @&quot;deprecated&quot;,&#10;                @&quot;obsolete&quot;,&#10;                @&quot;unreachable\s*code&quot;,&#10;                @&quot;unused\s*variable&quot;,&#10;                @&quot;unused\s*parameter&quot;,&#10;                @&quot;conversion\s*warning&quot;,&#10;                @&quot;truncation\s*warning&quot;&#10;            };&#10;&#10;            return warningPatterns.Any(pattern =&gt;&#10;                System.Text.RegularExpressions.Regex.IsMatch(message, pattern, System.Text.RegularExpressions.RegexOptions.IgnoreCase));&#10;        }&#10;&#10;&#10;        private bool ValidateInputs()&#10;        {&#10;            try&#10;            {&#10;                if (string.IsNullOrWhiteSpace(SourcePathTextBox.Text))&#10;                {&#10;                    WriteToTerminal(&quot;错误: 请选择插件 .uplugin 文件&quot;, TerminalMessageType.Error);&#10;                    return false;&#10;                }&#10;&#10;                if (!File.Exists(SourcePathTextBox.Text) || !SourcePathTextBox.Text.EndsWith(&quot;.uplugin&quot;))&#10;                {&#10;                    WriteToTerminal(&quot;错误: 请选择有效的 .uplugin 文件&quot;, TerminalMessageType.Error);&#10;                    return false;&#10;                }&#10;&#10;                if (string.IsNullOrWhiteSpace(OutputPathTextBox.Text))&#10;                {&#10;                    WriteToTerminal(&quot;错误: 请选择输出路径&quot;, TerminalMessageType.Error);&#10;                    return false;&#10;                }&#10;&#10;                if (SingleBuildRadio.IsChecked == true)&#10;                {&#10;                    if (EngineVersionComboBox.SelectedItem == null)&#10;                    {&#10;                        WriteToTerminal(&quot;错误: 请选择引擎版本&quot;, TerminalMessageType.Error);&#10;                        return false;&#10;                    }&#10;&#10;                    var selectedEngine = GetSelectedEngine();&#10;                    if (selectedEngine == null || !selectedEngine.IsValid)&#10;                    {&#10;                        WriteToTerminal(&quot;错误: 选择的引擎无效或不存在&quot;, TerminalMessageType.Error);&#10;                        return false;&#10;                    }&#10;                }&#10;                else if (BatchBuildRadio.IsChecked == true)&#10;                {&#10;                    var selectedEngines = GetSelectedEnginesForBatch();&#10;                    if (!selectedEngines.Any())&#10;                    {&#10;                        WriteToTerminal(&quot;错误: 批量构建需要至少选择一个引擎版本&quot;, TerminalMessageType.Error);&#10;                        return false;&#10;                    }&#10;&#10;                    var invalidEngines = selectedEngines.Where(e =&gt; !e.IsValid).ToList();&#10;                    if (invalidEngines.Any())&#10;                    {&#10;                        WriteToTerminal($&quot;错误: 以下引擎无效: {string.Join(&quot;, &quot;, invalidEngines.Select(e =&gt; e.DisplayName))}&quot;, TerminalMessageType.Error);&#10;                        return false;&#10;                    }&#10;                }&#10;&#10;                return true;&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;验证输入时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;                return false;&#10;            }&#10;        }&#10;&#10;        private UnrealEngineInfo GetSelectedEngine()&#10;        {&#10;            try&#10;            {&#10;                var selectedItem = EngineVersionComboBox.SelectedItem as ComboBoxItem;&#10;                return selectedItem?.Tag as UnrealEngineInfo;&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;获取选择引擎时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;                return null;&#10;            }&#10;        }&#10;&#10;        private List&lt;UnrealEngineInfo&gt; GetSelectedEnginesForBatch()&#10;        {&#10;            try&#10;            {&#10;                return _engineCheckBoxes&#10;                    .Where(cb =&gt; cb.IsChecked == true)&#10;                    .Select(cb =&gt; cb.Tag as UnrealEngineInfo)&#10;                    .Where(engine =&gt; engine != null)&#10;                    .ToList();&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;获取批量引擎列表时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;                return new List&lt;UnrealEngineInfo&gt;();&#10;            }&#10;        }&#10;&#10;        private string BuildRunUATCommand(UnrealEngineInfo engine)&#10;        {&#10;            var runUATPath = Path.Combine(engine.EnginePath, &quot;Engine&quot;, &quot;Build&quot;, &quot;BatchFiles&quot;, &quot;RunUAT.bat&quot;);&#10;            var pluginPath = SourcePathTextBox.Text;&#10;            var outputPath = GetFinalOutputPath(engine);&#10;&#10;            var args = new List&lt;string&gt;&#10;            {&#10;                &quot;BuildPlugin&quot;,&#10;                $&quot;-Plugin=\&quot;{pluginPath}\&quot;&quot;,&#10;                $&quot;-Package=\&quot;{outputPath}\&quot;&quot;,&#10;                &quot;-Rocket&quot;&#10;            };&#10;&#10;            var buildConfig = GetSelectedBuildType();&#10;            if (buildConfig != &quot;Development&quot;)&#10;            {&#10;                args.Add($&quot;-{buildConfig}&quot;);&#10;            }&#10;&#10;            var platforms = GetSelectedPlatforms();&#10;            if (platforms.Length &gt; 0)&#10;            {&#10;                args.Add($&quot;-TargetPlatforms={string.Join(&quot;+&quot;, platforms)}&quot;);&#10;            }&#10;&#10;            args.Add(&quot;-VS2022&quot;);&#10;&#10;            if (CleanBuildCheckBox.IsChecked.GetValueOrDefault())&#10;            {&#10;                args.Add(&quot;-Clean&quot;);&#10;            }&#10;&#10;            return $&quot;\&quot;{runUATPath}\&quot; {string.Join(&quot; &quot;, args)}&quot;;&#10;        }&#10;&#10;        private string GetPluginBuildName()&#10;        {&#10;            try&#10;            {&#10;                if (!string.IsNullOrWhiteSpace(PluginNameTextBox.Text))&#10;                    return PluginNameTextBox.Text.Trim();&#10;&#10;                if (_currentPluginInfo != null &amp;&amp; !string.IsNullOrEmpty(_currentPluginInfo.FriendlyName))&#10;                    return _currentPluginInfo.FriendlyName;&#10;&#10;                if (!string.IsNullOrEmpty(SourcePathTextBox.Text))&#10;                    return Path.GetFileNameWithoutExtension(SourcePathTextBox.Text);&#10;&#10;                return &quot;UnnamedPlugin&quot;;&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;获取插件构建名称时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;                return &quot;UnnamedPlugin&quot;;&#10;            }&#10;        }&#10;&#10;        private string GetFinalOutputPath(UnrealEngineInfo engine)&#10;        {&#10;            var basePath = OutputPathTextBox.Text;&#10;            var pluginName = GetPluginBuildName();&#10;            var versionSuffix = _currentPluginInfo != null ? $&quot;_v{_currentPluginInfo.GetVersionString()}&quot; : &quot;&quot;;&#10;            var engineVersion = engine?.Version ?? &quot;Unknown&quot;;&#10;&#10;            return Path.Combine(basePath, $&quot;{pluginName}{versionSuffix}_{engineVersion}&quot;);&#10;        }&#10;&#10;        private string GetSelectedBuildType()&#10;        {&#10;            if (DevelopmentRadio.IsChecked.GetValueOrDefault())&#10;                return &quot;Development&quot;;&#10;            if (ShippingRadio.IsChecked.GetValueOrDefault())&#10;                return &quot;Shipping&quot;;&#10;            if (DebugRadio.IsChecked.GetValueOrDefault())&#10;                return &quot;Debug&quot;;&#10;            return &quot;Development&quot;;&#10;        }&#10;&#10;        private string[] GetSelectedPlatforms()&#10;        {&#10;            var platforms = new List&lt;string&gt;();&#10;&#10;            if (Win64CheckBox.IsChecked.GetValueOrDefault())&#10;                platforms.Add(&quot;Win64&quot;);&#10;            if (Win32CheckBox.IsChecked.GetValueOrDefault())&#10;                platforms.Add(&quot;Win32&quot;);&#10;            if (MacCheckBox.IsChecked.GetValueOrDefault())&#10;                platforms.Add(&quot;Mac&quot;);&#10;            if (LinuxCheckBox.IsChecked.GetValueOrDefault())&#10;                platforms.Add(&quot;Linux&quot;);&#10;            if (AndroidCheckBox.IsChecked.GetValueOrDefault())&#10;                platforms.Add(&quot;Android&quot;);&#10;            if (iOSCheckBox.IsChecked.GetValueOrDefault())&#10;                platforms.Add(&quot;IOS&quot;);&#10;&#10;            return platforms.ToArray();&#10;        }&#10;&#10;        private void UpdateBatchProgress(string status, int current, int total)&#10;        {&#10;            try&#10;            {&#10;                DispatcherQueue.TryEnqueue(() =&gt;&#10;                {&#10;                    if (BatchProgressStatusText != null) BatchProgressStatusText.Text = status;&#10;                    if (BatchProgressText != null) BatchProgressText.Text = $&quot;{current}/{total}&quot;;&#10;                    if (BatchProgressBar != null &amp;&amp; total &gt; 0)&#10;                    {&#10;                        BatchProgressBar.Value = (current * 100.0) / total;&#10;                    }&#10;                });&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                WriteToTerminal($&quot;更新批量进度时出错: {ex.Message}&quot;, TerminalMessageType.Error);&#10;            }&#10;        }&#10;&#10;        #endregion&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>